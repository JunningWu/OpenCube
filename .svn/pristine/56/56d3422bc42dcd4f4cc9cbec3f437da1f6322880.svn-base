# 1 "pcoder_tb.cc"
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 
 
# 43 "coder_tb.cc"


 


 


 
 
 

 
 
 

 
 

 
 
 


 
 

 
# 82 "coder_tb.cc"



# 1 "/home/nando/archivos/trabajo/methodology/general.h" 1
 
 
 
 
 
 
 
 
 
 
 
 




 
 
 
 


 


 
 
 
 


 


 


 
 


 
 




 





 

 
 
 
 
 

 
 
 

 
 
# 131 "/home/nando/archivos/trabajo/methodology/general.h"



 
 
# 206 "/home/nando/archivos/trabajo/methodology/general.h"



 

  
# 1 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/stdio.h" 1


 























































 

# 1 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/pkgconf/isoinfra.h" 1


 


















































































































































# 61 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/stdio.h" 2


 

 




# 1 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/stddef.h" 1
 
 





























































# 1 "/home/nando/soft/OR1k5DevKit/build/gcc-2.95.3/../../install/gcc-2.95.3/lib/gcc-lib/or1k/2.95.3/include/stddef.h" 1 3 4






 


# 19 "/home/nando/soft/OR1k5DevKit/build/gcc-2.95.3/../../install/gcc-2.95.3/lib/gcc-lib/or1k/2.95.3/include/stddef.h" 3 4



 


 





 


# 61 "/home/nando/soft/OR1k5DevKit/build/gcc-2.95.3/../../install/gcc-2.95.3/lib/gcc-lib/or1k/2.95.3/include/stddef.h" 3 4


 





 


















 





 

 

# 131 "/home/nando/soft/OR1k5DevKit/build/gcc-2.95.3/../../install/gcc-2.95.3/lib/gcc-lib/or1k/2.95.3/include/stddef.h" 3 4


 

 


































typedef unsigned int size_t;






















 




 

# 271 "/home/nando/soft/OR1k5DevKit/build/gcc-2.95.3/../../install/gcc-2.95.3/lib/gcc-lib/or1k/2.95.3/include/stddef.h" 3 4


# 283 "/home/nando/soft/OR1k5DevKit/build/gcc-2.95.3/../../install/gcc-2.95.3/lib/gcc-lib/or1k/2.95.3/include/stddef.h" 3 4


 

 

# 317 "/home/nando/soft/OR1k5DevKit/build/gcc-2.95.3/../../install/gcc-2.95.3/lib/gcc-lib/or1k/2.95.3/include/stddef.h" 3 4




 





















# 64 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/stddef.h" 2


 
# 70 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/stdio.h" 2




# 1 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/cyg/libc/stdio/stdio.h" 1


 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 

# 1 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/pkgconf/libc_stdio.h" 1


 
































# 58 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/cyg/libc/stdio/stdio.h" 2


 

# 1 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/cyg/infra/cyg_type.h" 1



 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

# 1 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/stddef.h" 1
 
 





























































# 1 "/home/nando/soft/OR1k5DevKit/build/gcc-2.95.3/../../install/gcc-2.95.3/lib/gcc-lib/or1k/2.95.3/include/stddef.h" 1 3 4






 







 

 




 


 





 


# 61 "/home/nando/soft/OR1k5DevKit/build/gcc-2.95.3/../../install/gcc-2.95.3/lib/gcc-lib/or1k/2.95.3/include/stddef.h" 3 4


 





 


















 





 

 





















typedef int ptrdiff_t;









 




 

 


# 188 "/home/nando/soft/OR1k5DevKit/build/gcc-2.95.3/../../install/gcc-2.95.3/lib/gcc-lib/or1k/2.95.3/include/stddef.h" 3 4





 




 





























 



















































typedef unsigned int  wint_t;




 

 

# 317 "/home/nando/soft/OR1k5DevKit/build/gcc-2.95.3/../../install/gcc-2.95.3/lib/gcc-lib/or1k/2.95.3/include/stddef.h" 3 4




 













 







# 64 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/stddef.h" 2


 
# 58 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/cyg/infra/cyg_type.h" 2


 
 

 
 






 


 
 
 
 
 




# 1 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/cyg/hal/basetype.h" 1



 
 
 
 
 
 
 
 
 
 
 
 
 
 

 

 
 




 
 



# 1 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/cyg/hal/hal_cache.h" 1



 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

# 1 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/cyg/infra/cyg_type.h" 1
# 432 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/cyg/infra/cyg_type.h"

 
# 22 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/cyg/hal/hal_cache.h" 2


 
 













  









  









 
 


# 75 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/cyg/hal/hal_cache.h"

# 88 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/cyg/hal/hal_cache.h"

# 109 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/cyg/hal/hal_cache.h"


# 131 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/cyg/hal/hal_cache.h"


# 144 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/cyg/hal/hal_cache.h"








# 162 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/cyg/hal/hal_cache.h"

 
 


# 179 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/cyg/hal/hal_cache.h"

# 192 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/cyg/hal/hal_cache.h"

# 213 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/cyg/hal/hal_cache.h"




# 228 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/cyg/hal/hal_cache.h"








# 246 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/cyg/hal/hal_cache.h"

 
 


# 261 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/cyg/hal/hal_cache.h"


# 274 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/cyg/hal/hal_cache.h"


# 287 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/cyg/hal/hal_cache.h"


# 300 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/cyg/hal/hal_cache.h"

 
 


# 316 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/cyg/hal/hal_cache.h"



 
 
# 32 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/cyg/hal/basetype.h" 2




 
 
# 83 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/cyg/infra/cyg_type.h" 2



















































 
 
 
 




 







 
 
 





# 170 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/cyg/infra/cyg_type.h"


 
 
 













 
 
 







 
 
 

typedef unsigned char     cyg_uint8  ;
typedef   signed char     cyg_int8   ;

typedef unsigned short    cyg_uint16 ;
typedef   signed short    cyg_int16  ;

typedef unsigned int    cyg_uint32 ;
typedef   signed int    cyg_int32  ;

typedef unsigned long long    cyg_uint64 ;
typedef   signed long long    cyg_int64  ;

typedef  int             cyg_bool   ;

 
 
 
 

typedef unsigned int   cyg_ucount8  ;
typedef   signed int   cyg_count8   ;

typedef unsigned int  cyg_ucount16 ;
typedef   signed int  cyg_count16  ;

typedef unsigned int  cyg_ucount32 ;
typedef   signed int  cyg_count32  ;

typedef unsigned long long  cyg_ucount64 ;
typedef   signed long long  cyg_count64  ;

 
 
 
 

typedef volatile unsigned char    cyg_atomic;
typedef volatile unsigned char    CYG_ATOMIC;

 
 

typedef cyg_uint32  CYG_WORD;
typedef cyg_uint8   CYG_BYTE;
typedef cyg_uint16  CYG_WORD16;
typedef cyg_uint32  CYG_WORD32;
typedef cyg_uint64  CYG_WORD64;

typedef cyg_uint32   CYG_ADDRESS;
typedef cyg_uint32  CYG_ADDRWORD;

 
 
 









    
 
 






















 
 
 
 
 
 
 
 
 













 
 


 




 




 
 




 
 





 
 
 







 
 




 




 




 



# 390 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/cyg/infra/cyg_type.h"


 
 










 
 
 
 
 
 














 
 
 




 

 
# 62 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/cyg/libc/stdio/stdio.h" 2

# 1 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/stdarg.h" 1
 
 






























































# 1 "/home/nando/soft/OR1k5DevKit/build/gcc-2.95.3/../../install/gcc-2.95.3/lib/gcc-lib/or1k/2.95.3/include/stdarg.h" 1 3 4
 
































































 






typedef void *__gnuc_va_list;



 



 

















void va_end (__gnuc_va_list);		 


 








 







 























 
 













# 175 "/home/nando/soft/OR1k5DevKit/build/gcc-2.95.3/../../install/gcc-2.95.3/lib/gcc-lib/or1k/2.95.3/include/stdarg.h" 3 4


 




 

 

 

typedef __gnuc_va_list va_list;
























# 65 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/stdarg.h" 2


 
# 63 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/cyg/libc/stdio/stdio.h" 2


 

 
 

 
 





 
 


 
 





 

 
 
typedef cyg_ucount32 fpos_t;


 
 
 
 
 
 
 
 
 
typedef CYG_ADDRESS FILE[9999];

 

 
 
 
 
 


extern "C"  FILE *stdin, *stdout, *stderr;


 

 

 

extern "C"   int
fclose( FILE *   );

extern "C"   int
fflush( FILE *   );

extern "C"   FILE *
fopen( const char *  , const char *   );

extern "C"   FILE *
freopen( const char *  , const char *  ,
         FILE *   );

extern "C"   void
setbuf( FILE *  , char *   );

extern "C"   int
setvbuf( FILE *  , char *  , int  ,
         size_t   );

 

 

extern "C"   int
fprintf( FILE *  , const char *  , ... );

extern "C"   int
fscanf( FILE *  , const char *  , ... );

extern "C"   int
printf( const char *  , ... );

extern "C"   int
scanf( const char *  , ... );

extern "C"   int
sprintf( char *  , const char *  , ... );

extern "C"   int
sscanf( const char *  , const char *  , ... );

extern "C"   int
vfprintf( FILE *  , const char *  ,
          va_list   );

extern "C"   int
vprintf( const char *  , va_list   );

extern "C"   int
vsprintf( char *  , const char *  ,
          va_list   );

 

 

extern "C"   int
fgetc( FILE *   );

extern "C"   char *
fgets( char *  , int  , FILE *   );

extern "C"   int
fputc( int  , FILE *   );

extern "C"   int
putc( int  , FILE *   );

extern "C"   int
putchar( int   );

extern "C"   int
fputs( const char *  , FILE *   );

extern "C"   char *
gets( char * );

extern "C"   int
getc( FILE *   );

extern "C"   int
getchar( void );

extern "C"   int
puts( const char *   );

extern "C"   int
ungetc( int  , FILE *   );

 
 





 

 

extern "C"   size_t
fread( void *  , size_t  ,
       size_t  , FILE *   );

extern "C"   size_t
fwrite( const void *  , size_t  ,
        size_t  , FILE *   );

 

 

extern "C"   int
fgetpos( FILE *  , fpos_t *   );

extern "C"   int
fseek( FILE *  , long int  , int   );

extern "C"   int
fsetpos( FILE *  , const fpos_t *   );

extern "C"   long int
ftell( FILE *   );

extern "C"   void
rewind( FILE *   );

 

 

extern "C"   void
clearerr( FILE *   );

extern "C"   int
feof( FILE *   );

extern "C"   int
ferror( FILE *   );

extern "C"   void
perror( const char *   );

 

 

extern "C"   int
fnprintf( FILE *  , size_t  ,
          const char *  , ... ) __attribute__((format (printf,  3 ,   4 ))) ;

extern "C"   int
snprintf( char *  , size_t  , const char *  ,
          ... ) __attribute__((format (printf,  3 ,   4 ))) ;

extern "C"   int
vfnprintf( FILE *  , size_t  ,
           const char *  , va_list   );

extern "C"   int
vsnprintf( char *  , size_t  ,
           const char *  , va_list   );

extern "C"   int
vscanf( const char *  , va_list   );

extern "C"   int
vsscanf( const char *  , const char *  ,
         va_list   );

extern "C"   int
vfscanf( FILE *  , const char *  ,
         va_list   );


 


# 1 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/cyg/libc/stdio/stdio.inl" 1


 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 



 


# 1 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/stddef.h" 1
 
 





























































# 1 "/home/nando/soft/OR1k5DevKit/build/gcc-2.95.3/../../install/gcc-2.95.3/lib/gcc-lib/or1k/2.95.3/include/stddef.h" 1 3 4
# 342 "/home/nando/soft/OR1k5DevKit/build/gcc-2.95.3/../../install/gcc-2.95.3/lib/gcc-lib/or1k/2.95.3/include/stddef.h" 3 4

# 64 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/stddef.h" 2


 
# 63 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/cyg/libc/stdio/stdio.inl" 2

# 1 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/stdarg.h" 1
 
 
































































 
# 64 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/cyg/libc/stdio/stdio.inl" 2

# 1 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/stdio.h" 1
# 147 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/stdio.h"


 
# 65 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/cyg/libc/stdio/stdio.inl" 2

# 1 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/errno.h" 1


 
























































 



 


# 1 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/cyg/error/codes.h" 1


 






































































 

# 1 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/pkgconf/error.h" 1


 














# 76 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/cyg/error/codes.h" 2



extern "C" {


 

 



typedef int Cyg_ErrNo;


 

 


















    


    



    


    

                                




    




    
 






 



 










                                



 

















}    




 
# 67 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/errno.h" 2




# 1 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/cyg/error/errno.h" 1


 





















































 





 




extern "C" {


 




extern Cyg_ErrNo *
cyg_error_get_errno_p( void ) __attribute__((const));




 








}    






 
# 71 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/errno.h" 2





 
# 66 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/cyg/libc/stdio/stdio.inl" 2

# 1 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/string.h" 1


 

























































 



 

 




# 1 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/stddef.h" 1
 
 





























































# 1 "/home/nando/soft/OR1k5DevKit/build/gcc-2.95.3/../../install/gcc-2.95.3/lib/gcc-lib/or1k/2.95.3/include/stddef.h" 1 3 4






 


# 19 "/home/nando/soft/OR1k5DevKit/build/gcc-2.95.3/../../install/gcc-2.95.3/lib/gcc-lib/or1k/2.95.3/include/stddef.h" 3 4



 


 





 


# 61 "/home/nando/soft/OR1k5DevKit/build/gcc-2.95.3/../../install/gcc-2.95.3/lib/gcc-lib/or1k/2.95.3/include/stddef.h" 3 4


 





 


















 





 

 


# 126 "/home/nando/soft/OR1k5DevKit/build/gcc-2.95.3/../../install/gcc-2.95.3/lib/gcc-lib/or1k/2.95.3/include/stddef.h" 3 4


 




 

 


# 188 "/home/nando/soft/OR1k5DevKit/build/gcc-2.95.3/../../install/gcc-2.95.3/lib/gcc-lib/or1k/2.95.3/include/stddef.h" 3 4





 




 


# 269 "/home/nando/soft/OR1k5DevKit/build/gcc-2.95.3/../../install/gcc-2.95.3/lib/gcc-lib/or1k/2.95.3/include/stddef.h" 3 4
















 

 

# 317 "/home/nando/soft/OR1k5DevKit/build/gcc-2.95.3/../../install/gcc-2.95.3/lib/gcc-lib/or1k/2.95.3/include/stddef.h" 3 4




 













 







# 64 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/stddef.h" 2


 
# 72 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/string.h" 2



# 1 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/cyg/error/strerror.h" 1


 





















































 



 




extern "C" {


 

 



extern char *
strerror( Cyg_ErrNo );

 



extern char *
__strerror( Cyg_ErrNo );


}    




 
# 75 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/string.h" 2



 







extern 

"C"

void *
memcpy( void *, const void *, size_t );







extern 

"C"

void *
memset( void *, int, size_t );




# 1 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/cyg/libc/string/string.h" 1


 






















































 

# 1 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/pkgconf/libc_string.h" 1


 















# 60 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/cyg/libc/string/string.h" 2



extern "C" {


 

 

 

extern void *
memmove( void *, const void *, size_t );

extern char *
strcpy( char *, const char * );

extern char *
strncpy( char *, const char *, size_t );

 

 

extern char *
strcat( char *, const char * );

extern char *
strncat( char *, const char *, size_t );


 

 

extern int
memcmp( const void *, const void *, size_t );

extern int
strcmp( const char *, const char * );

extern int
strcoll( const char *, const char * );

extern int
strncmp( const char *, const char *, size_t );

extern size_t
strxfrm( char *, const char *, size_t );


 

 

extern void *
memchr( const void *, int,  size_t );

extern char *
strchr( const char *, int );

extern size_t
strcspn( const char *, const char * );

extern char *
strpbrk( const char *, const char * );

extern char *
strrchr( const char *, int );

extern size_t
strspn( const char *, const char * );

extern char *
strstr( const char *, const char * );

extern char *
strtok( char *, const char * );

 

extern char *
strtok_r( char *, const char *, char ** );


 

 

extern size_t
strlen( const char * );


}    


 


# 1 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/cyg/libc/string/string.inl" 1


 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 



 

extern __inline__ int
strcoll( const char *s1, const char *s2 )
{
    return strcmp(s1, s2);
}  




 
# 160 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/cyg/libc/string/string.h" 2





 
# 109 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/string.h" 2








# 1 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/cyg/libc/string/bsdstring.h" 1


 





















































 






# 1 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/stddef.h" 1
 
 





























































# 1 "/home/nando/soft/OR1k5DevKit/build/gcc-2.95.3/../../install/gcc-2.95.3/lib/gcc-lib/or1k/2.95.3/include/stddef.h" 1 3 4






 


# 19 "/home/nando/soft/OR1k5DevKit/build/gcc-2.95.3/../../install/gcc-2.95.3/lib/gcc-lib/or1k/2.95.3/include/stddef.h" 3 4



 


 





 


# 61 "/home/nando/soft/OR1k5DevKit/build/gcc-2.95.3/../../install/gcc-2.95.3/lib/gcc-lib/or1k/2.95.3/include/stddef.h" 3 4


 





 


















 





 

 


# 126 "/home/nando/soft/OR1k5DevKit/build/gcc-2.95.3/../../install/gcc-2.95.3/lib/gcc-lib/or1k/2.95.3/include/stddef.h" 3 4


 




 

 


# 188 "/home/nando/soft/OR1k5DevKit/build/gcc-2.95.3/../../install/gcc-2.95.3/lib/gcc-lib/or1k/2.95.3/include/stddef.h" 3 4





 




 


# 269 "/home/nando/soft/OR1k5DevKit/build/gcc-2.95.3/../../install/gcc-2.95.3/lib/gcc-lib/or1k/2.95.3/include/stddef.h" 3 4
















 

 

# 317 "/home/nando/soft/OR1k5DevKit/build/gcc-2.95.3/../../install/gcc-2.95.3/lib/gcc-lib/or1k/2.95.3/include/stddef.h" 3 4




 













 







# 64 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/stddef.h" 2


 
# 64 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/cyg/libc/string/bsdstring.h" 2



extern "C" {


 

 


extern int
strcasecmp( const char *  , const char *   );

extern int
strncasecmp( const char *  , const char *  , size_t   );

extern int
bcmp( const void *  , const void *  , size_t   );

extern void
bcopy( const void *  , void *  , size_t   );

extern void
bzero( void *  , size_t   );

extern char *
index( const char *  , int   );

extern char *
rindex( const char *  , int   );

extern void
swab( const void *  , void *  , size_t   );

 


}    






 
# 117 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/string.h" 2













 
# 67 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/cyg/libc/stdio/stdio.inl" 2

# 1 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/limits.h" 1


 

























































 



 

 







 


 


 


 


 


 


 


 


 



 


 


 


 


 


 


 


 


 


 


 


 


 


 


 


 


 


 


 


 











 








































        

 




# 1 "/home/nando/soft/OR1k5DevKit/build/gcc-2.95.3/../../install/gcc-2.95.3/lib/gcc-lib/or1k/2.95.3/include/limits.h" 1 3 4



 



 



 




 





 



 












 

 




 



 








 



 













 




 








 






# 220 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/limits.h" 2


 
# 68 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/cyg/libc/stdio/stdio.inl" 2


 

 

 

extern __inline__ void
setbuf( FILE *stream, char *buf )
{
    if (buf == __null )
        setvbuf( stream, __null , (-8) , 0 );
    else
         
         
         
        setvbuf( stream, buf, (-4) , 256  );

}  

 

 

extern __inline__ int
vfprintf( FILE *stream, const char *format, va_list arg )
{
    return vfnprintf(stream, 2147483647  , format, arg);
}  


extern __inline__ int
vprintf( const char *format, va_list arg )
{
    return vfnprintf(stdout, 2147483647  , format, arg);
}  


extern __inline__ int
vsprintf( char *s, const char *format, va_list arg )
{
    return vsnprintf(s, 2147483647  , format, arg);
}  


 

 

extern __inline__ int
puts( const char *s )
{
    int rc;

    rc = fputs( s, stdout );

    if (rc >= 0)
        rc = fputc('\n', stdout );

    return rc;
}  


 

 

extern __inline__ void
perror( const char *s )
{
    if (s && *s)
        fprintf( stderr, "%s: %s\n", s, strerror((*cyg_error_get_errno_p()) ) );
    else
        fputs( strerror((*cyg_error_get_errno_p()) ), stderr );

}  

 

 

extern __inline__ int
vscanf( const char *format, va_list arg )
{
    return vfscanf( stdin, format, arg );
}  




 
# 303 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/cyg/libc/stdio/stdio.h" 2





 
# 74 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/stdio.h" 2


























































extern "C" {


extern int
fileno( FILE *__stream );

extern FILE *
fdopen( int __fildes, const char *__type );


}  






 
# 211 "/home/nando/archivos/trabajo/methodology/general.h" 2

  
# 1 "/home/nando/archivos/trabajo/methodology/SC2OS/SC2OS.h" 1
 
 
 
 
 
 
 
 
 



 




 
 
 
 
 

 
# 1 "/home/nando/archivos/trabajo/methodology/SC2OS/types/uc_uint.h" 1
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 








 

 

































 





































































 
 


































template <int W>
class uc_uint {
public:
     
	inline uc_uint();
	inline uc_uint(int par);
	inline uc_uint(unsigned int par);

	 
	 
	inline void operator = (int par) ;
	inline void operator = (unsigned int par) ;

	 
	operator unsigned int ();

	inline bool operator [] ( int par );  
     

private:
	unsigned int value;  
};


 

 
template<int W>
uc_uint<W>::uc_uint() {}

template<int W>
uc_uint<W>::uc_uint(int par) { value = (unsigned int) par;}

template<int W>
uc_uint<W>::uc_uint(unsigned int par) { value = par;}

 
template<int W>
void uc_uint<W>::operator=(int par) {
	 
	value = (unsigned int) par;
}

template<int W>
void uc_uint<W>::operator=(unsigned int par) {
	 
	value = par;
}

template<int W>
uc_uint<W>::operator unsigned int () {
	return value;
}

template<int W>
inline bool uc_uint<W>::operator[](int par) {
	unsigned int temp;
	if((W-1)<par) {  
					 
		return false;
	} else {
		temp=value>>par;
		return temp&0x1;
	}
}




# 270 "/home/nando/archivos/trabajo/methodology/SC2OS/types/uc_uint.h"

# 25 "/home/nando/archivos/trabajo/methodology/SC2OS/SC2OS.h" 2






# 212 "/home/nando/archivos/trabajo/methodology/general.h" 2


  



  
    
# 1 "/home/nando/archivos/trabajo/methodology/SC2eCos/SC2eCos.h" 1
 
 
 
 
 
 
 
 
 
 
 
 





 
# 1 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/cyg/kernel/kapi.h" 1



 
























































# 1 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/pkgconf/system.h" 1


 

























































































































# 61 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/cyg/kernel/kapi.h" 2

# 1 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/pkgconf/kernel.h" 1


 







 

# 1 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/pkgconf/hal.h" 1


 







 

# 1 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/pkgconf/hal_or1k.h" 1


 










# 13 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/pkgconf/hal.h" 2




# 1 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/pkgconf/hal_or1k_or1ksim.h" 1


 


















# 17 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/pkgconf/hal.h" 2

 



























# 13 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/pkgconf/kernel.h" 2

# 1 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/pkgconf/infra.h" 1


 







 

 





# 14 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/pkgconf/kernel.h" 2







 




































































# 62 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/cyg/kernel/kapi.h" 2





 


extern "C" {


 
 
 

typedef CYG_ADDRWORD   cyg_addrword_t;       
typedef cyg_addrword_t cyg_handle_t;         
typedef cyg_uint32     cyg_priority_t;       
typedef cyg_int32      cyg_code_t;           
typedef cyg_uint32     cyg_vector_t;         
typedef cyg_uint32     cyg_cpu_t;            

typedef cyg_uint64 cyg_tick_count_t;

typedef int cyg_bool_t;

 
typedef void cyg_exception_handler_t(
    cyg_addrword_t data,
    cyg_code_t   exception_number,
    cyg_addrword_t info
);

 
struct cyg_thread;
typedef struct cyg_thread cyg_thread;

struct cyg_interrupt;
typedef struct cyg_interrupt cyg_interrupt;

struct cyg_counter;
typedef struct cyg_counter cyg_counter;

struct cyg_clock;
typedef struct cyg_clock cyg_clock;

struct cyg_alarm;
typedef struct cyg_alarm cyg_alarm;

struct cyg_mbox;
typedef struct cyg_mbox cyg_mbox;

struct cyg_sem_t;
typedef struct cyg_sem_t cyg_sem_t;

struct cyg_flag_t;
typedef struct cyg_flag_t cyg_flag_t;

struct cyg_mutex_t;
typedef struct cyg_mutex_t cyg_mutex_t;

struct cyg_cond_t;
typedef struct cyg_cond_t cyg_cond_t;

struct cyg_spinlock_t;
typedef struct cyg_spinlock_t cyg_spinlock_t;

 
 

 
void cyg_scheduler_start(void) __attribute__((noreturn)) ;

 
 
void cyg_scheduler_lock(void);

void cyg_scheduler_unlock(void);

 
 
 
void cyg_scheduler_safe_lock(void);
    
 
cyg_ucount32 cyg_scheduler_read_lock(void);

 
 

typedef void cyg_thread_entry_t(cyg_addrword_t);

void cyg_thread_create(
    cyg_addrword_t      sched_info,              
    cyg_thread_entry_t  *entry,                  
    cyg_addrword_t      entry_data,              
    char                *name,                   
    void                *stack_base,             
    cyg_ucount32        stack_size,              
    cyg_handle_t        *handle,                 
    cyg_thread          *thread                  
);
    
void cyg_thread_exit(void);

 
cyg_bool_t cyg_thread_delete(cyg_handle_t thread);  

void cyg_thread_suspend(cyg_handle_t thread);

void cyg_thread_resume(cyg_handle_t thread);

void cyg_thread_kill(cyg_handle_t thread);

void cyg_thread_release(cyg_handle_t thread);    
    
void cyg_thread_yield(void);

cyg_handle_t cyg_thread_self(void);

cyg_handle_t cyg_thread_idle_thread(void);

 

void cyg_thread_set_priority(cyg_handle_t thread, cyg_priority_t priority );

cyg_priority_t cyg_thread_get_priority(cyg_handle_t thread);              
cyg_priority_t cyg_thread_get_current_priority(cyg_handle_t thread); 

 

void cyg_thread_deadline_wait( 
    cyg_tick_count_t    start_time,              
    cyg_tick_count_t    run_time,                
    cyg_tick_count_t    deadline                 
); 

void cyg_thread_delay(cyg_tick_count_t delay);

 
cyg_addrword_t cyg_thread_get_stack_base(cyg_handle_t thread);

cyg_uint32 cyg_thread_get_stack_size(cyg_handle_t thread);


cyg_uint32 cyg_thread_measure_stack_usage(cyg_handle_t thread);


 
 
    
typedef struct
{
    cyg_handle_t        handle;
    cyg_uint16          id;
    cyg_uint32          state;
    char                *name;
    cyg_priority_t      set_pri;
    cyg_priority_t      cur_pri;
    cyg_addrword_t      stack_base;
    cyg_uint32          stack_size;
    cyg_uint32          stack_used;
} cyg_thread_info;
    
cyg_bool_t cyg_thread_get_next( cyg_handle_t *thread, cyg_uint16 *id );

cyg_bool_t cyg_thread_get_info( cyg_handle_t thread,
                                cyg_uint16 id,
                                cyg_thread_info *info );

cyg_handle_t cyg_thread_find( cyg_uint16 id );
    
 
 



cyg_ucount32 cyg_thread_new_data_index(void);

void cyg_thread_free_data_index(cyg_ucount32 index);

CYG_ADDRWORD cyg_thread_get_data(cyg_ucount32 index);

CYG_ADDRWORD *cyg_thread_get_data_ptr(cyg_ucount32 index);

void cyg_thread_set_data(cyg_ucount32 index, CYG_ADDRWORD data);


    
 
 

# 262 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/cyg/kernel/kapi.h"

    
 
 

 
 
 

void cyg_exception_set_handler(
    cyg_code_t                  exception_number,
    cyg_exception_handler_t     *new_handler,
    cyg_addrword_t                new_data,
    cyg_exception_handler_t     **old_handler,
    cyg_addrword_t                *old_data
);

 
void cyg_exception_clear_handler(
    cyg_code_t                  exception_number
);
    
 
void cyg_exception_call_handler(
    cyg_handle_t                thread,
    cyg_code_t                  exception_number,
    cyg_addrword_t              exception_info
);


 
 
typedef void            cyg_VSR_t(void);
typedef cyg_uint32      cyg_ISR_t(cyg_vector_t vector, cyg_addrword_t data);
typedef void            cyg_DSR_t( cyg_vector_t vector,
                                   cyg_ucount32 count,
                                   cyg_addrword_t data);


enum cyg_ISR_results
{
    CYG_ISR_HANDLED  = 1,                
    CYG_ISR_CALL_DSR = 2                 
};

void cyg_interrupt_create(
    cyg_vector_t        vector,          
    cyg_priority_t      priority,        
    cyg_addrword_t      data,            
    cyg_ISR_t           *isr,            
    cyg_DSR_t           *dsr,            
    cyg_handle_t        *handle,         
    cyg_interrupt       *intr            
);

void cyg_interrupt_delete( cyg_handle_t interrupt );

void cyg_interrupt_attach( cyg_handle_t interrupt );

void cyg_interrupt_detach( cyg_handle_t interrupt );
    
 

void cyg_interrupt_get_vsr(
    cyg_vector_t        vector,          
    cyg_VSR_t           **vsr            
);

void cyg_interrupt_set_vsr(
    cyg_vector_t        vector,          
    cyg_VSR_t           *vsr             
);

 
void cyg_interrupt_disable(void);

void cyg_interrupt_enable(void);

 
void cyg_interrupt_mask(cyg_vector_t vector);
void cyg_interrupt_mask_intunsafe(cyg_vector_t vector);

void cyg_interrupt_unmask(cyg_vector_t vector);
void cyg_interrupt_unmask_intunsafe(cyg_vector_t vector);

void cyg_interrupt_acknowledge(cyg_vector_t vector);

void cyg_interrupt_configure(
    cyg_vector_t        vector,          
    cyg_bool_t          level,           
    cyg_bool_t          up               
);

void cyg_interrupt_set_cpu(
    cyg_vector_t        vector,          
    cyg_cpu_t           cpu              
);

cyg_cpu_t cyg_interrupt_get_cpu(
    cyg_vector_t        vector           
);
    
 
 

void cyg_counter_create(
    cyg_handle_t        *handle,         
    cyg_counter         *counter         
);

void cyg_counter_delete(cyg_handle_t counter);

 
cyg_tick_count_t cyg_counter_current_value(cyg_handle_t counter);

 
void cyg_counter_set_value(
    cyg_handle_t        counter,
    cyg_tick_count_t new_value
);

 
void cyg_counter_tick(cyg_handle_t counter);

 
void cyg_counter_multi_tick(cyg_handle_t counter, cyg_tick_count_t _ticks);






typedef struct 
{
    cyg_uint32  dividend; cyg_uint32  divisor; 
} cyg_resolution_t;

 
void cyg_clock_create(
    cyg_resolution_t    resolution,      
    cyg_handle_t        *handle,         
    cyg_clock           *clock               
);

void cyg_clock_delete(cyg_handle_t clock);

 
 
void cyg_clock_to_counter(
    cyg_handle_t        clock,
    cyg_handle_t        *counter
);

void cyg_clock_set_resolution(
    cyg_handle_t        clock,
    cyg_resolution_t    resolution       
);

cyg_resolution_t cyg_clock_get_resolution(cyg_handle_t clock);

 
cyg_handle_t cyg_real_time_clock(void);

 



cyg_tick_count_t cyg_current_time(void);

 
typedef void cyg_alarm_t(cyg_handle_t alarm, cyg_addrword_t data);

void cyg_alarm_create(
    cyg_handle_t        counter,         
    cyg_alarm_t         *alarmfn,        
    cyg_addrword_t      data,            
    cyg_handle_t        *handle,         
    cyg_alarm           *alarm               
);

 
void cyg_alarm_delete( cyg_handle_t alarm);

void cyg_alarm_initialize(
    cyg_handle_t        alarm,
    cyg_tick_count_t    trigger,         
    cyg_tick_count_t    interval         
);

void cyg_alarm_get_times(
    cyg_handle_t        alarm,
    cyg_tick_count_t    *trigger,        
    cyg_tick_count_t    *interval        
);

void cyg_alarm_enable( cyg_handle_t alarm );

void cyg_alarm_disable( cyg_handle_t alarm );

 
 
void cyg_mbox_create(
    cyg_handle_t        *handle,
    cyg_mbox            *mbox
);

void cyg_mbox_delete(cyg_handle_t mbox);

void *cyg_mbox_get(cyg_handle_t mbox);








void *cyg_mbox_tryget(cyg_handle_t mbox);

void *cyg_mbox_peek_item(cyg_handle_t mbox);


cyg_bool_t cyg_mbox_put(cyg_handle_t mbox, void *item);









cyg_bool_t cyg_mbox_tryput(cyg_handle_t mbox, void *item);

cyg_count32 cyg_mbox_peek(cyg_handle_t mbox);

cyg_bool_t cyg_mbox_waiting_to_get(cyg_handle_t mbox);

cyg_bool_t cyg_mbox_waiting_to_put(cyg_handle_t mbox);


 
 

 
 


# 1 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/cyg/memalloc/kapi.h" 1



 























































 

# 1 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/pkgconf/memalloc.h" 1


 























# 62 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/cyg/memalloc/kapi.h" 2


 

struct cyg_mempool_var;
typedef struct cyg_mempool_var cyg_mempool_var;

struct cyg_mempool_fix;
typedef struct cyg_mempool_fix cyg_mempool_fix;

 
 

 




 
void cyg_mempool_var_create(
    void            *base,               
    cyg_int32       size,                
    cyg_handle_t    *handle,             
    cyg_mempool_var *var                 
    );

 
void cyg_mempool_var_delete(cyg_handle_t varpool);



 

void *cyg_mempool_var_alloc(cyg_handle_t varpool, cyg_int32 size);

# 107 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/cyg/memalloc/kapi.h"



 

void *cyg_mempool_var_try_alloc(
    cyg_handle_t varpool,
    cyg_int32    size);

 
void cyg_mempool_var_free(cyg_handle_t varpool, void *p);

 

cyg_bool_t cyg_mempool_var_waiting(cyg_handle_t varpool);

typedef struct {
    cyg_int32 totalmem;
    cyg_int32 freemem;
    void      *base;
    cyg_int32 size;
    cyg_int32 blocksize;
    cyg_int32 maxfree;                   
} cyg_mempool_info;

 

void cyg_mempool_var_get_info(cyg_handle_t varpool, cyg_mempool_info *info);

 
void cyg_mempool_fix_create(
    void            *base,               
    cyg_int32       size,                
    cyg_int32       blocksize,           
    cyg_handle_t    *handle,             
    cyg_mempool_fix *fix                 
    );

 
void cyg_mempool_fix_delete(cyg_handle_t fixpool);


 

void *cyg_mempool_fix_alloc(cyg_handle_t fixpool);

# 162 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/cyg/memalloc/kapi.h"



 
void *cyg_mempool_fix_try_alloc(cyg_handle_t fixpool);

 
void cyg_mempool_fix_free(cyg_handle_t fixpool, void *p);

 

cyg_bool_t cyg_mempool_fix_waiting(cyg_handle_t fixpool);

 

void cyg_mempool_fix_get_info(cyg_handle_t fixpool, cyg_mempool_info *info);




 
# 510 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/cyg/kernel/kapi.h" 2



 
 

void      cyg_semaphore_init(
    cyg_sem_t           *sem,             
    cyg_count32         val               
);

void cyg_semaphore_destroy( cyg_sem_t *sem );

cyg_bool_t cyg_semaphore_wait( cyg_sem_t *sem );








cyg_bool_t cyg_semaphore_trywait( cyg_sem_t *sem );

void cyg_semaphore_post( cyg_sem_t *sem );

void cyg_semaphore_peek( cyg_sem_t *sem, cyg_count32 *val );

 
 

typedef cyg_uint32 cyg_flag_value_t;
typedef cyg_uint8  cyg_flag_mode_t;




void cyg_flag_init(
    cyg_flag_t        *flag              
);

void cyg_flag_destroy( cyg_flag_t *flag );

 

void cyg_flag_setbits( cyg_flag_t *flag, cyg_flag_value_t value);

 

void cyg_flag_maskbits( cyg_flag_t *flag, cyg_flag_value_t value);

 




cyg_flag_value_t cyg_flag_wait( cyg_flag_t        *flag,
                                cyg_flag_value_t   pattern, 
                                cyg_flag_mode_t    mode );









cyg_flag_value_t cyg_flag_poll( cyg_flag_t         *flag,
                                cyg_flag_value_t    pattern, 
                                cyg_flag_mode_t     mode );

cyg_flag_value_t cyg_flag_peek( cyg_flag_t *flag );

cyg_bool_t cyg_flag_waiting( cyg_flag_t *flag );

 
 


enum cyg_mutex_protocol
{
  CYG_MUTEX_NONE = 0,                    
  CYG_MUTEX_INHERIT,                     
  CYG_MUTEX_CEILING                      
};


void cyg_mutex_init(
    cyg_mutex_t        *mutex           
);

void cyg_mutex_destroy( cyg_mutex_t *mutex );

cyg_bool_t cyg_mutex_lock( cyg_mutex_t *mutex );

cyg_bool_t cyg_mutex_trylock( cyg_mutex_t *mutex );

void cyg_mutex_unlock( cyg_mutex_t *mutex );

void cyg_mutex_release( cyg_mutex_t *mutex );


void cyg_mutex_set_ceiling( cyg_mutex_t *mutex, cyg_priority_t priority );



void cyg_mutex_set_protocol ( cyg_mutex_t *mutex, enum cyg_mutex_protocol protocol );


 
 

void cyg_cond_init(
    cyg_cond_t          *cond,           
    cyg_mutex_t         *mutex           
);

void cyg_cond_destroy( cyg_cond_t *cond );

cyg_bool_t cyg_cond_wait( cyg_cond_t *cond );

void cyg_cond_signal( cyg_cond_t *cond );

void cyg_cond_broadcast( cyg_cond_t *cond );








 
 

void cyg_spinlock_init(
    cyg_spinlock_t      *lock,           
    cyg_bool_t          locked           
);

void cyg_spinlock_destroy( cyg_spinlock_t *lock );

void cyg_spinlock_spin( cyg_spinlock_t *lock );

void cyg_spinlock_clear( cyg_spinlock_t *lock );

cyg_bool_t cyg_spinlock_try( cyg_spinlock_t *lock );

cyg_bool_t cyg_spinlock_test( cyg_spinlock_t *lock );

void cyg_spinlock_spin_intsave( cyg_spinlock_t *lock,
                                cyg_addrword_t *istate );

void cyg_spinlock_clear_intsave( cyg_spinlock_t *lock,
                                 cyg_addrword_t istate );

 

}


 

# 1 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/cyg/kernel/kapidata.h" 1



 

















































































# 1 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/cyg/hal/hal_intr.h" 1



 
 
 
 
 
 
 
 
 
 
 
 
 
 
 










 
 
































 
 

typedef cyg_uint32 CYG_INTERRUPT_STATE;

 
 


# 86 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/cyg/hal/hal_intr.h"


# 98 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/cyg/hal/hal_intr.h"


# 111 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/cyg/hal/hal_intr.h"










 
 











 
 

 









 
 

extern "C"   volatile CYG_ADDRESS  hal_interrupt_handlers[2 ];
extern "C"   volatile CYG_ADDRWORD hal_interrupt_data[2 ];
extern "C"   volatile CYG_ADDRESS  hal_interrupt_objects[2 ];

extern "C"   volatile CYG_ADDRESS hal_vsr_table[15 +1];

extern "C"   cyg_uint32 hal_default_isr(CYG_ADDRWORD vector, CYG_ADDRWORD data);



# 168 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/cyg/hal/hal_intr.h"


# 180 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/cyg/hal/hal_intr.h"


# 192 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/cyg/hal/hal_intr.h"



    








extern "C"   void _default_exception_vsr(void);
extern "C"   void _default_interrupt_vsr(void);










 
 


# 233 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/cyg/hal/hal_intr.h"


# 247 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/cyg/hal/hal_intr.h"





 
 

extern "C"   CYG_WORD32 cyg_hal_clock_period;


# 273 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/cyg/hal/hal_intr.h"


# 287 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/cyg/hal/hal_intr.h"


# 297 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/cyg/hal/hal_intr.h"

# 307 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/cyg/hal/hal_intr.h"




 
 
# 86 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/cyg/kernel/kapidata.h" 2


 


extern "C" {


 














typedef cyg_ucount32 cyg_sched_bitmap;






typedef struct 
{






    cyg_thread *queue;

# 134 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/cyg/kernel/kapidata.h"

} cyg_threadqueue;
    
 

struct cyg_interrupt
{
    cyg_vector_t        vector;
    cyg_priority_t      priority;
    cyg_ISR_t           *isr;
    cyg_DSR_t           *dsr;
    CYG_ADDRWORD        data;


    cyg_ucount32        dsr_count;
    cyg_interrupt       *next_dsr;




};


 

















struct cyg_counter
{
    cyg_alarm           *alarm_list;  cyg_tick_count_t    counter; cyg_uint32          increment; 
};

 

struct cyg_clock
{
    cyg_alarm           *alarm_list;  cyg_tick_count_t    counter; cyg_uint32          increment; 
    cyg_uint32  dividend; cyg_uint32  divisor; 
};

 




















struct cyg_alarm
{
    cyg_alarm           *next; cyg_alarm           *prev;  cyg_counter         *counter; cyg_alarm_t         *alarm; CYG_ADDRWORD        data; cyg_tick_count_t    trigger; cyg_tick_count_t    interval; cyg_bool            enabled; 
};

 
 













typedef struct
{
    cyg_exception_handler_t *exception_handler; CYG_ADDRWORD            exception_data;     
} cyg_exception_control;



 
 











                                         




typedef void cyg_thread_entry(CYG_ADDRWORD data);










typedef struct
{
    CYG_ADDRESS         stack_base; cyg_uint32          stack_size; CYG_ADDRESS         stack_limit;  CYG_ADDRESS         stack_ptr; cyg_thread_entry   *entry_point; CYG_ADDRWORD        entry_data; void                *saved_context;  
} cyg_hardwarethread;

 
 

























# 305 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/cyg/kernel/kapidata.h"

















































    
typedef struct 
{
    cyg_thread *next; cyg_thread *prev; cyg_priority_t      priority;      cyg_threadqueue     *queue;   cyg_count32         mutex_count; cyg_priority_t      original_priority; cyg_bool            priority_inherited;   
} cyg_schedthread;

 













 
 

typedef struct 
{
    cyg_alarm           alarm; cyg_thread          *thread; 
} cyg_threadtimer;


typedef enum
{
    CYG_REASON_NONE,
    CYG_REASON_WAIT,
    CYG_REASON_DELAY,
    CYG_REASON_TIMEOUT,
    CYG_REASON_BREAK,
    CYG_REASON_DESTRUCT,
    CYG_REASON_EXIT,
    CYG_REASON_DONE
} cyg_reason_t;



















































# 464 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/cyg/kernel/kapidata.h"


struct cyg_thread
{
    CYG_ADDRESS         stack_base; cyg_uint32          stack_size; CYG_ADDRESS         stack_limit;  CYG_ADDRESS         stack_ptr; cyg_thread_entry   *entry_point; CYG_ADDRWORD        entry_data; void                *saved_context;   cyg_thread *next; cyg_thread *prev; cyg_priority_t      priority;      cyg_threadqueue     *queue;   cyg_count32         mutex_count; cyg_priority_t      original_priority; cyg_bool            priority_inherited;    cyg_uint32                  state; cyg_ucount32                suspend_count; cyg_ucount32                wakeup_count; CYG_ADDRWORD                wait_info; cyg_uint16                  unique_id;     cyg_reason_t        sleep_reason; cyg_reason_t        wake_reason; CYG_ADDRWORD        thread_data[6 ];    char                *name;  cyg_thread          *list_next;  
};

 

struct cyg_mbox
{
    cyg_count32         base;            
    cyg_count32         count;           
    cyg_threadqueue     get_threadq;     

    cyg_threadqueue     put_threadq;     

    void *              itemqueue[ 10  ];
};

 

struct cyg_sem_t
{
    cyg_count32         count;           
    cyg_threadqueue     queue;               
};

 

struct cyg_flag_t
{
    cyg_flag_value_t    value;           
    cyg_threadqueue     queue;               
};

 

typedef enum
{
    CYG_MUTEX_PROTOCOL_NONE,
    CYG_MUTEX_PROTOCOL_INHERIT,
    CYG_MUTEX_PROTOCOL_CEILING
} cyg_mutex_protocol_t;

struct cyg_mutex_t
{
    cyg_atomic          locked;          
    cyg_thread          *owner;          
    cyg_threadqueue     queue;           


    cyg_mutex_protocol_t protocol;        


    cyg_priority_t      ceiling;         

    
};

 

struct cyg_cond_t
{
    cyg_mutex_t         *mutex;          
    cyg_threadqueue     queue;           
};

 

struct cyg_spinlock_t
{
    cyg_uint32          lock;            
};

 

 
 


# 1 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/cyg/memalloc/kapidata.h" 1



 

























































 

 

typedef struct cyg_mempoolt {
    cyg_threadqueue queue;
} cyg_mempoolt;


struct cyg_mempool_var_memdq {
    struct cyg_mempool_var_memdq *prev, *next;
    cyg_int32 size;
};

struct cyg_mempool_var {
    struct cyg_mempool_var_memdq head;
    cyg_uint8  *obase;
    cyg_int32  osize;
    cyg_uint8  *bottom;
    cyg_uint8  *top;
    cyg_int32  alignment;
    cyg_int32  freemem;
    cyg_mempoolt mempoolt;
};

struct cyg_mempool_fix {
    cyg_uint32 *bitmap;
    cyg_int32 maptop;
    cyg_uint8  *mempool;
    cyg_int32 numblocks;
    cyg_int32 freeblocks;
    cyg_int32 blocksize;
    cyg_int32 firstfree;
    cyg_uint8  *top;
    cyg_mempoolt mempoolt;
};


 
# 545 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/cyg/kernel/kapidata.h" 2




}


 
 

# 674 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/cyg/kernel/kapi.h" 2


 
 


# 19 "/home/nando/archivos/trabajo/methodology/SC2eCos/SC2eCos.h" 2


 
 
 
 








# 1 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/cyg/infra/diag.h" 1



 























































# 1 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/stdarg.h" 1
 
 
































































 
# 60 "/home/nando/soft/ecos/configurations/openrisc/or32_20non_preemp_ram_stack_noRTC_prueba_install/include/cyg/infra/diag.h" 2


 
 

extern "C"   void diag_init(void);          

extern "C"   void diag_write_char(char c);  

extern "C"   void diag_write_string(const char *psz);  

extern "C"   void diag_write_dec( cyg_int32 n);     

extern "C"   void diag_write_hex( cyg_uint32 n);    

extern "C"   void diag_dump_buf(void *buf, CYG_ADDRWORD len);
extern "C"   void diag_dump_buf_32bit(void *buf, CYG_ADDRWORD len);
extern "C"   void diag_dump_buf_16bit(void *buf, CYG_ADDRWORD len);
typedef int __printf_fun(const char *fmt, ...);
extern "C"   void diag_vdump_buf_with_offset(__printf_fun *pf,
                                        cyg_uint8     *p, 
                                        CYG_ADDRWORD   s, 
                                        cyg_uint8     *base);
extern "C"   void diag_dump_buf_with_offset(cyg_uint8     *p, 
                                       CYG_ADDRWORD   s, 
                                       cyg_uint8     *base);

extern "C"   void diag_dump_buf_with_offset_32bit(cyg_uint32 *p, 
                                             CYG_ADDRWORD     s, 
                                             cyg_uint32      *base);

extern "C"   void diag_dump_buf_with_offset_16bit(cyg_uint16 *p, 
                                             CYG_ADDRWORD     s, 
                                             cyg_uint16      *base);

extern "C"   int  diag_printf( const char *fmt, ... );   

extern "C"   void diag_init_putc(void (*putc)(char c, void **param));
extern "C"   int  diag_sprintf(char *buf, const char *fmt, ...);
extern "C"   int  diag_snprintf(char *buf, size_t len, const char *fmt, ...);
extern "C"   int  diag_vsprintf(char *buf, const char *fmt, va_list ap);
extern "C"   int  diag_vprintf(const char *fmt, va_list ap);


 
 




 

 
# 33 "/home/nando/archivos/trabajo/methodology/SC2eCos/SC2eCos.h" 2




 

 
 
 
 
 

 
 
 
 
 

 
 
 







 
# 1 "/home/nando/archivos/trabajo/methodology/SC2eCos/kernel/uc_interface.h" 1
 
 
 
 
 
 
 
 
 
 
 
 




 
 
 
class uc_interface {
   
};


# 62 "/home/nando/archivos/trabajo/methodology/SC2eCos/SC2eCos.h" 2

# 1 "/home/nando/archivos/trabajo/methodology/SC2eCos/kernel/uc_module_name.h" 1
 
 
 
 
 
 
 
 
 
 




 
 
 
 
 
 
 

class uc_module_name {
public:
   
   
  uc_module_name(const char* ) {;};
  uc_module_name(const uc_module_name&) {;};
};


# 63 "/home/nando/archivos/trabajo/methodology/SC2eCos/SC2eCos.h" 2

# 1 "/home/nando/archivos/trabajo/methodology/SC2eCos/kernel/uc_module.h" 1
 
 
 
 
 
 
 
 
 
 
 




 
 
 
 
 
 
 
 

 
 
 
 

























 
 
 





 


 


 








class exec_context;

class uc_module {
  friend class exec_context;
};


# 64 "/home/nando/archivos/trabajo/methodology/SC2eCos/SC2eCos.h" 2

# 1 "/home/nando/archivos/trabajo/methodology/SC2eCos/kernel/uc_port.h" 1
 
 
 
 
 
 
 
 
 
 




 
 
 

template<class IF>
class uc_port{
public:

   
 





   
  void  operator()(IF& channel_interface_port) {
     
     
     
    port_interface=&channel_interface_port;
    attached_to_a_parent_port = false;
	 
	 
  }

   
  void  operator()(uc_port<IF> &parent_port) {
     
     
     
    upper_port=&parent_port;
    attached_to_a_parent_port = true;
     
	 
  }

  IF *access() {
	 
 
    if (attached_to_a_parent_port) {
	   
 
      return upper_port->access();
    }
    else {
	   
 
      return port_interface;
	}
  }

  IF *operator->() {
    return access();
  }

private:
  IF *port_interface;
  uc_port<IF> *upper_port;
  bool attached_to_a_parent_port;

};


# 65 "/home/nando/archivos/trabajo/methodology/SC2eCos/SC2eCos.h" 2


 
# 1 "/home/nando/archivos/trabajo/methodology/SC2eCos/kernel/uc_thread.h" 1
 
 
 
 
 
 
 
 
 
 
 




 
 
 
class uc_module;

 
typedef void (uc_module::*UC_ENTRY_FUNC)();
 
 

class proc_b {
public:

  UC_ENTRY_FUNC entry_fn;
  uc_module*    module;     

  void execute()  {
    (module->*entry_fn)();
  }

};

class ecos_thread : public proc_b {
public:
 
 
  char                 stack[8192 ];  
  cyg_handle_t         handle;     				   
  cyg_thread           space;       			   

  char				name[50 ];

};


# 68 "/home/nando/archivos/trabajo/methodology/SC2eCos/SC2eCos.h" 2

# 1 "/home/nando/archivos/trabajo/methodology/SC2eCos/kernel/exec_context.h" 1
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 



 
 
 
 
 
 

 

 

class exec_context {
public:

  exec_context() {
    for(unsigned int i=0; i< 11 ; i++)
      assigned[i]=false;
    tr_index=0;
  }
  
   
   
  void register_thread_process(UC_ENTRY_FUNC fn, uc_module* mod,
								char *name,
  								unsigned int stack_size) {
      system_thread[tr_index].entry_fn = fn;
      system_thread[tr_index].module   = mod;
	  
	   

	  for(unsigned int i=0; i< 50 ;i++) {
	  	system_thread[tr_index].name[i] = name[i];
	  	if(name[i]=='\0') break;
	  }

	  
      cyg_thread_create(4,
                        create_sys_thread,
                        (cyg_addrword_t) &system_thread[tr_index],
						name,
                        (void *) system_thread[tr_index].stack,
 
						stack_size,
						&(system_thread[tr_index].handle),
                        &(system_thread[tr_index].space));
      assigned[tr_index]=true;
	  
      tr_index++;
  }

   
   
   
   
   
  
  static void create_sys_thread(cyg_addrword_t process) {
    ecos_thread *sys_thread;
 
    sys_thread = (ecos_thread *) process;
    sys_thread->execute();
  }


 
 
  
  void start_threads() {
 
    for(unsigned i=0;(i< 11 )&&assigned[i]; i++) {
 
 
 
 
 
      cyg_thread_resume(system_thread[i].handle);
	}
 
  }

 
 
 
 
 
 
 
 
 
 
 
 
 
  void print_stack_use();

  
private:
  ecos_thread system_thread[11 ];
  bool assigned[11 ];
  unsigned int tr_index;  
};


void exec_context::print_stack_use() {
    for(unsigned i=0;(i< 11 )&&assigned[i]; i++) {
		 
		diag_printf ("Stack for process [%d] %s = %d\n", i, system_thread[i].name, cyg_thread_measure_stack_usage(system_thread[i].handle));
    	 
	}
}


static exec_context execution_context;

void uc_start(int) {

 
   
  execution_context.start_threads();
 
   
  cyg_scheduler_start();
 
	 
	 
	 
	 
	 
	 
}


# 69 "/home/nando/archivos/trabajo/methodology/SC2eCos/SC2eCos.h" 2

# 1 "/home/nando/archivos/trabajo/methodology/SC2eCos/kernel/uc_wait.h" 1
 
 
 
 
 
 
 
 
 
 
 




 
 
 
 
 
 
 
 

enum sc_time_unit
{
    SC_FS = 0,
    SC_PS,
    SC_NS,
    SC_US,
    SC_MS,
    SC_SEC
};

 
 
 
inline void uc_wait( double value, sc_time_unit tu) {

  unsigned int tick_count;
  double unit_mult;

  switch (tu) {
    case SC_FS:
      unit_mult= 0.0000000000001;
      break;
    case SC_PS:
      unit_mult= 0.0000000001;
      break;
    case SC_NS:
      unit_mult= 0.0000001;
      break;
    case SC_US:
      unit_mult= 0.0001;
      break;
    case SC_MS:
      unit_mult= 0.1;
      break;
    default:
      unit_mult= 100.0;

  }

   
  tick_count = (unsigned int) (unit_mult*value);

  cyg_thread_delay(tick_count);

};


# 70 "/home/nando/archivos/trabajo/methodology/SC2eCos/SC2eCos.h" 2


 












 
						 
 
class dummy_class {};

	
 
int sc_main(int ac, char *av[]);
extern "C" void cyg_user_start(void) { sc_main(0,(char **)0);}



# 219 "/home/nando/archivos/trabajo/methodology/general.h" 2

  

   
   
  

   
  
	
		
# 1 "/home/nando/archivos/trabajo/methodology/utils/OpenRISC/target_prof.cc" 1
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 





 

 


 
 




 
 




# 102 "/home/nando/archivos/trabajo/methodology/utils/OpenRISC/target_prof.cc"


 

 
 
 
 
 
 
 
 
 
 
  

 
 

   
   
   

  
  
  
  

   
  
 
  
   

  
  
  
  

  

  
   
  
 
  
  
class target_prof {
public:	
	 
	target_prof();
	 
	~target_prof();

	 
	void show_current();

	 
	 
	 
	void show_results();
		
	 
	inline void inChannelCounter();
	 
	inline void threadCounter();

	 
	inline void enable();
	 
	inline void disable();

	 
	inline void reset(short int counter_id);
	 
	inline void reset();

	 
	unsigned int readCounter(unsigned short counter_id);

	 
	 
	 
	void show_counters();

	 
	unsigned short get_thread_id();
	
private:

	cyg_handle_t thread;
	cyg_uint16	id;
	cyg_thread_info info;

 
 
 
	volatile unsigned int *p;
	short i,found;
	unsigned int value;
};


target_prof::target_prof() {
	diag_printf ("Profiling Object creation/reset\n");
	disable();
	reset();
	show_counters();
	show_results();
	diag_printf ("Count will start with the first executed BEGIN_PROF...\n");
	
}

target_prof::~target_prof() {
	diag_printf ("Destruction of profiling object...\n");	
	show_results();
}

void target_prof::show_current() {
	disable();	
	id = get_thread_id();
		 
	if(!cyg_thread_get_info(thread,id,&info)) {
		diag_printf ("Thread %d does not exist\n",id);
	}
	diag_printf ("[%d] %s = %d\n",info.id,info.name?info.name:"----",readCounter(info.id));
	enable();
}

void target_prof::show_results() {
	thread = 0;
	id=0;
 
 
 
	 
	diag_printf ("[0] %u CHANNEL/OS\n",readCounter(0));
	 
	while(cyg_thread_get_next(&thread,&id)) {
		if(!cyg_thread_get_info(thread,id,&info)) {
			diag_printf ("Thread %d does not exist\n",id);
			break;
		}
		value = readCounter(info.id);
		diag_printf ("[%d] %u %s\n",info.id,value,info.name?info.name:"----");
	}
	
	 
	 
	 
	 
	 
	inChannelCounter();
}

void target_prof::show_counters() {
	diag_printf ("Relevant counters state...\n");	
	for(i=0;i<(3+ 11 );i++) {
		diag_printf ("counter %d: %u\n",i,readCounter((unsigned int)i));
	}

	 
	 
	 
	 
	 
	inChannelCounter();	
}


inline void target_prof::inChannelCounter() {

	p=(unsigned int *)0x94000000 ;
	*p= 0 ;  

}

inline void target_prof::threadCounter() {

	p=(unsigned int *)0x94000000 ;
 
	*p=(unsigned int)get_thread_id();  
										 
 


}

 

inline void target_prof::enable() {
	p=(unsigned int *)0x9400000C ;
	*p=0x1;
}

inline void target_prof::disable() {
	p=(unsigned int *)0x9400000C ;
	*p=0x0;	
}

inline void target_prof::reset(short int counter_id) {
	p=(unsigned int *)0x94000000 ;
	*p=counter_id;
	p=(unsigned int *)0x94000008 ;
	*p=0;  
}

inline void target_prof::reset() {
	 
	 
	 
	 
	 
	 
	for(i=0;i<(3+ 11 );i++) {
		reset(i);
	}
}

 
 
unsigned short target_prof::get_thread_id() {
	found = -1;
	 
	thread = cyg_thread_self();
	 
	 
	 
	 
	 
	for(i=2;i<(3+ 11 );i++) {
		if(thread==cyg_thread_find(i)) {
			found = i;
			break;
		}
	}
	return found;
}

 
 
 
 
 
unsigned int target_prof::readCounter(unsigned short counter_id) {

	p=(unsigned int *)0x94000000 ;
	*p=counter_id;
	value=0;
	

	 
	 
	
	 
	p=(unsigned int *)0x94000004 ;
	*p = 0x0;
	p=(unsigned int *)0x94000008 ;
	value = *p;
	value = value << 8;
 
 
	 
	p=(unsigned int *)0x94000004 ;
	*p = 0x1;
	p=(unsigned int *)0x94000008 ;
	value = value|*p;
	value = value << 8;
 
 
	 
	p=(unsigned int *)0x94000004 ;
	*p = 0x2;
	p=(unsigned int *)0x94000008 ;
	value = value|*p;
	value = value << 8;
 
 

	 
	p=(unsigned int *)0x94000004 ;
	*p = 0x3;
	p=(unsigned int *)0x94000008 ;
	value = value|*p;
 
 
	
# 397 "/home/nando/archivos/trabajo/methodology/utils/OpenRISC/target_prof.cc"

	
	return value;




}

target_prof target_prof_hardware;


# 229 "/home/nando/archivos/trabajo/methodology/general.h" 2

		 
	






  







   
   
	   
  
	   
   
       
  
	   
  


 

# 277 "/home/nando/archivos/trabajo/methodology/general.h"


 
 





 
 
 
 
 
# 1 "/home/nando/soft/systemc-2.0.1/installdir/include/systemc/communication/sc_mutex_if.h" 1
 
















 







 












# 1 "/home/nando/soft/systemc-2.0.1/installdir/include/systemc/communication/sc_interface.h" 1
 
















 







 









# 88 "/home/nando/soft/systemc-2.0.1/installdir/include/systemc/communication/sc_interface.h"


 
# 39 "/home/nando/soft/systemc-2.0.1/installdir/include/systemc/communication/sc_mutex_if.h" 2



 
 
 
 
 

class sc_mutex_if
: virtual public uc_interface 
{
public:

     

     
    virtual int lock() = 0;

     
    virtual int trylock() = 0;

     
    virtual int unlock() = 0;

protected:

     

    sc_mutex_if()
	{}

private:

     
    sc_mutex_if( const sc_mutex_if& );
    sc_mutex_if& operator = ( const sc_mutex_if& );
};




 
# 291 "/home/nando/archivos/trabajo/methodology/general.h" 2

# 1 "/home/nando/soft/systemc-2.0.1/installdir/include/systemc/communication/sc_fifo_ifs.h" 1
 
















 







 













# 1 "/home/nando/soft/systemc-2.0.1/installdir/include/systemc/communication/sc_interface.h" 1
 
















 







 









# 88 "/home/nando/soft/systemc-2.0.1/installdir/include/systemc/communication/sc_interface.h"


 
# 40 "/home/nando/soft/systemc-2.0.1/installdir/include/systemc/communication/sc_fifo_ifs.h" 2



 
 
 
 
 

template <class T>
class sc_fifo_in_if
: virtual public uc_interface 
{
public:

     
    virtual void read( T& ) = 0;
    virtual T read() = 0;

     
    virtual bool nb_read( T& ) = 0;

     
    virtual int num_available() const = 0;

     
    virtual const dummy_class & data_written_event() const = 0;

protected:

     

    sc_fifo_in_if()
	{}

private:

     
    sc_fifo_in_if( const sc_fifo_in_if<T>& );
    sc_fifo_in_if<T>& operator = ( const sc_fifo_in_if<T>& );
};


 
 
 
 
 

template <class T>
class sc_fifo_out_if
: virtual public uc_interface 
{
public:

     
    virtual void write( const T& ) = 0;

     
    virtual bool nb_write( const T& ) = 0;

     
    virtual int num_free() const = 0;

     
    virtual const dummy_class & data_read_event() const = 0;

protected:

     

    sc_fifo_out_if()
	{}

private:

     
    sc_fifo_out_if( const sc_fifo_out_if<T>& );
    sc_fifo_out_if<T>& operator = ( const sc_fifo_out_if<T>& );
};




 
# 292 "/home/nando/archivos/trabajo/methodology/general.h" 2


 
# 1 "/home/nando/archivos/trabajo/methodology/interfaces/uc_simple_interface.h" 1
 













template <class T>
class uc_simple_write_if : virtual public uc_interface 
{
   public:
 
	virtual void write(const T&) = 0;

	 
	uc_simple_write_if<T>& operator = ( const T& par ) { write( par ); return *this; }
					 
	uc_simple_write_if<T>& operator = ( const uc_simple_write_if<T>& par ) { write( par.read() ); return *this; }
};

template <class T>
class uc_simple_read_if : virtual public uc_interface 
{
   public:
		virtual void read(T&) = 0;
		virtual T& read() = 0;
		 

		 
		operator const T& () const { return read(); }	
};


template <class T>
class uc_simple_read_write_if : virtual public uc_simple_write_if<T>,
                                virtual public uc_simple_read_if<T>
{
};


# 295 "/home/nando/archivos/trabajo/methodology/general.h" 2

# 1 "/home/nando/archivos/trabajo/methodology/interfaces/uc_nb_interface.h" 1
 
 
 
 
 
 
 
 
 
 




template <class T>
class uc_nb_write_if : virtual public uc_interface 
{
   public:
     virtual void nb_write(const T&) = 0;
};

template <class T>
class uc_nb_read_if : virtual public uc_interface 
{
   public:
    
     virtual void nb_read(T&) = 0;
};

template <class T>
class uc_nb_read_write_if : virtual public uc_nb_write_if<T>,
                            virtual public uc_nb_read_if<T>
{
};


# 296 "/home/nando/archivos/trabajo/methodology/general.h" 2

# 1 "/home/nando/archivos/trabajo/methodology/interfaces/uc_try_interface.h" 1
 
 
 
 
 
 
 
 
 
 
 




template <class T>
class uc_try_write_if : virtual public uc_interface 
{
   public:
     virtual void try_write(const T&) = 0;
};

template <class T>
class uc_try_read_if : virtual public uc_interface 
{
   public:
    
     virtual void try_read(T&) = 0;
};

template <class T>
class uc_try_read_write_if : virtual public uc_try_write_if<T>,
                             virtual public uc_try_read_if<T>
{
};


# 297 "/home/nando/archivos/trabajo/methodology/general.h" 2

# 1 "/home/nando/archivos/trabajo/methodology/interfaces/uc_extended_interface.h" 1
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 








 
template <class T>
class uc_extended_write_if : virtual public uc_simple_write_if<T>,
                             virtual public uc_nb_write_if<T>,
                             virtual public uc_try_write_if<T>
{
};

template <class T>
class uc_extended_read_if : virtual public uc_simple_read_if<T>,
                            virtual public uc_nb_read_if<T>,
                            virtual public uc_try_read_if<T>
{
};


template <class T>
class uc_extended_read_write_if : virtual public uc_extended_write_if<T>,
                                  virtual public uc_extended_read_if<T>
{
};


# 298 "/home/nando/archivos/trabajo/methodology/general.h" 2


 
# 1 "/home/nando/archivos/trabajo/methodology/interfaces/uc_sync_timed_settings_if.h" 1
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 




class uc_sync_timed_settings_if {
public:
 
  virtual void set_frec(unsigned int frec) =0;

   
   
  virtual void set_frec() =0;

   
   
 

};


# 301 "/home/nando/archivos/trabajo/methodology/general.h" 2

# 1 "/home/nando/archivos/trabajo/methodology/interfaces/uc_sync_interface.h" 1
 













class uc_sync_if : virtual public uc_interface 
{
   public:
	 virtual void sync() = 0;   
};

# 302 "/home/nando/archivos/trabajo/methodology/general.h" 2


# 1 "/home/nando/archivos/trabajo/methodology/interfaces/uc_fifo_interface.h" 1
 
 
 
 
 
 
 
 
 
 
 



# 1 "/home/nando/archivos/trabajo/methodology/interfaces/sc_fifo_ifs.h" 1
 
















 







 














# 131 "/home/nando/archivos/trabajo/methodology/interfaces/sc_fifo_ifs.h"


 
# 15 "/home/nando/archivos/trabajo/methodology/interfaces/uc_fifo_interface.h" 2


template <class T>
class uc_fifo_if : virtual public sc_fifo_in_if<T>,
                   virtual public sc_fifo_out_if<T> {
# 29 "/home/nando/archivos/trabajo/methodology/interfaces/uc_fifo_interface.h"

					   
};

# 304 "/home/nando/archivos/trabajo/methodology/general.h" 2

# 1 "/home/nando/archivos/trabajo/methodology/interfaces/uc_rv_interface.h" 1
 









 
 
 
 
 
 
 
 
 
 
 
 
 
 




 
 
 
 
template <class Tin,class Tout>
class uc_caller_if : virtual public uc_interface  {
public:
	 
	 
	virtual void call(
					Tin &data_in,		 
					Tout &data_out		 
					) = 0;
	
	 
	 
	virtual Tout& call_read() = 0;		 
	virtual void call_write(
					Tin &data_in		 
					) = 0; 
	
	 
	virtual void call() = 0;
};

template <class Tin,class Tout>
class uc_accepter_if : virtual public uc_interface  {
public:
	 
	 
	virtual void accept(
					Tin &data_in,	 
					Tout &data_out   
					) = 0;
	
	 
	virtual Tin& accept_read() = 0;  
	
	virtual void accept_write(
					Tout &data_out	 
					) = 0;
	
	 
	virtual void accept() = 0;
};

template <class Tin, class Tout>
class uc_rv_if : virtual public uc_caller_if<Tin,Tout>,
				virtual public uc_accepter_if<Tin,Tout> {};


# 305 "/home/nando/archivos/trabajo/methodology/general.h" 2


 




 

 
 
 

 
# 1 "/home/nando/archivos/trabajo/methodology/channels/channel_options.h" 1
 
 
 
 
 
 
 
 
 
 
 




 
 
 
 
 
 

 



 
 
 

 

 

 

 

 

 
 


 


 

# 60 "/home/nando/archivos/trabajo/methodology/channels/channel_options.h"


 
 
 







 

 

# 97 "/home/nando/archivos/trabajo/methodology/channels/channel_options.h"


 
 
 




 
 



 
 
 

 
 


 
 


 
 
 


 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 



 
 





 




# 319 "/home/nando/archivos/trabajo/methodology/general.h" 2


 
# 347 "/home/nando/archivos/trabajo/methodology/general.h"



	 
	
# 1 "/home/nando/archivos/trabajo/methodology/SC2eCos/sw_channels/SS_channel_implementations.h" 1
 
 
 
 
 
 
 
 
 
 
 
 
 




 

 

 

 

 

 

 
 


 


# 351 "/home/nando/archivos/trabajo/methodology/general.h" 2



# 388 "/home/nando/archivos/trabajo/methodology/general.h"


 



	 
	 
	 

	 

	
# 1 "/home/nando/archivos/trabajo/methodology/SC2eCos/sw_channels/sc_mutex_SS.h" 1
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 




class sc_mutex_SS : public sc_mutex_if {
public:
	 
	sc_mutex_SS(const char* name=0);
 
 
 

	 
 
		
	 

     
    int lock();

     
    int trylock();

     
    int unlock();

private:
	cyg_mutex_t		ecos_mutex;
	cyg_bool_t		return_value;
};


 

sc_mutex_SS::sc_mutex_SS(const char* name) {
 
	cyg_mutex_init(&ecos_mutex);
 
}
 




int sc_mutex_SS::lock() {
	return cyg_mutex_lock(&ecos_mutex);
	 
	 
}

int sc_mutex_SS::trylock() {
	return_value = cyg_mutex_trylock(&ecos_mutex);
	if (return_value)
		return return_value;
	else
		return -1;
}

int sc_mutex_SS::unlock() {
	
	cyg_mutex_unlock(&ecos_mutex);
	
	 
	 
	 
	 
	 
	 
	 
	
	return 1;
	
}


# 400 "/home/nando/archivos/trabajo/methodology/general.h" 2

	 
	 
	 
	
# 1 "/home/nando/archivos/trabajo/methodology/SC2eCos/sw_channels/sc_fifo_SS.h" 1
 
 
 
 
 
 
 
 
 
 
 
 
 
 






template <class T>
class sc_fifo_SS
: public sc_fifo_in_if<T>,
  public sc_fifo_out_if<T> {
public:
     
    explicit sc_fifo_SS( int size_ = 16){create_fifo(size_);}
    explicit sc_fifo_SS( const char* name_, int size_ = 16 ) {create_fifo(size_);}

     
 

     
    void read( T& );
    T read();

     
    bool nb_read( T& );
		
     
    int num_available() const;

     
    const dummy_class & data_written_event() const { return event_var;}

     
    void write( const T& );

     
    bool nb_write( const T& );

     
    int num_free() const;

     
    const dummy_class & data_read_event() const { return event_var; }

     
    operator T ()
	{ return read(); }

    sc_fifo_SS<T>& operator = ( const T& a )
        { write( a ); return *this; }

 

 
 


 

private:
	 

	dummy_class 	event_var;
	 
	T 				*buffer;
	T				tmpdata;
	unsigned int 	write_index;
	unsigned int 	read_index;
	unsigned int	size;

	 

	 
	cyg_sem_t		channel_sem;    
	 
	int	free_elements;				 
	cyg_flag_t		channel_flag;	 

	  

	cyg_mutex_t		writer_mutex;		 



	cyg_mutex_t		reader_mutex;		 

	 
 
	void reset();
	
	void create_fifo(int size_);
	
};

 
 
 
template <class T>
inline void sc_fifo_SS<T>::create_fifo(int size_) {
    size = (unsigned int) size_;  
     
     
     
	reset();
	buffer = new T[size];
}

template <class T>
inline void sc_fifo_SS<T>::reset() {
	write_index = 0;
	read_index = 0;
	cyg_semaphore_init(&channel_sem,size);
 
	 
	 
	 
	 
	 
    cyg_flag_init(&channel_flag);	
    cyg_flag_maskbits(&channel_flag,0x00000000);   
	 
	

	cyg_mutex_init(&writer_mutex);



	cyg_mutex_init(&reader_mutex);

	
}

 

template <class T>
inline void sc_fifo_SS<T>::read(T& data) {
     

	 
	 
	 
    cyg_mutex_lock(&reader_mutex);

	 
	cyg_flag_wait(&channel_flag,0x1 ,((cyg_flag_mode_t)2) );
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
    data = buffer[read_index];
	 
    if(read_index>=size) 
		read_index=0;   
	else
		read_index++;
	
	cyg_semaphore_peek(&channel_sem,&free_elements);
	if((unsigned int)free_elements >= (size-1) )  
		cyg_flag_maskbits(&channel_flag,~0x1 );
	

	cyg_mutex_unlock(&reader_mutex);

	
	 
	cyg_semaphore_post(&channel_sem);
	
}

template <class T>
inline T sc_fifo_SS<T>::read() {
    read(tmpdata);
    return tmpdata;
}


 

template <class T>
inline bool sc_fifo_SS<T>::nb_read(T& data) {
     

	 
	 
	 
    cyg_mutex_lock(&reader_mutex);


	 

	if(cyg_flag_poll(&channel_flag,0x1 ,((cyg_flag_mode_t)2) )) {
		 
		data = buffer[read_index];

		 
		if(read_index>=size) 
			read_index=0;   
		else
			read_index++;
	
		cyg_semaphore_peek(&channel_sem,&free_elements);
		if((unsigned int)free_elements>=(size-1))  
			cyg_flag_maskbits(&channel_flag,~0x1 );
	

		cyg_mutex_unlock(&reader_mutex);

		 
		cyg_semaphore_post(&channel_sem);
		
		return true;   

	} else {

		cyg_mutex_unlock(&reader_mutex);

		return false;
	}
}

template <class T>
inline int sc_fifo_SS<T>::num_available() const {
 
 
	return 0;
}

 

template <class T>
inline void sc_fifo_SS<T>::write(const T& data) {
	 
	cyg_semaphore_wait(&channel_sem);
	 
	 
	 

    cyg_mutex_lock(&writer_mutex);

	 
    buffer[write_index] = data;

	 
    if(write_index>=size) 
		write_index=0;   
	else
		write_index++;
	 
	 
	cyg_flag_setbits(&channel_flag,0x1 );

	cyg_mutex_unlock(&writer_mutex);

	
}

 

template <class T>
inline bool sc_fifo_SS<T>::nb_write(const T& data) {
	 
	if(cyg_semaphore_trywait(&channel_sem)) {
		 
		 
		 

		cyg_mutex_lock(&writer_mutex);

	
		 
		buffer[write_index] = data;

		 
		if(write_index>=size) 
			write_index=0;   
		else
			write_index++;
			 
		 
		cyg_flag_setbits(&channel_flag,0x1 );
		

		cyg_mutex_unlock(&writer_mutex);

		return true;		
	} else {
		return false;
	}
}


template <class T>
inline int sc_fifo_SS<T>::num_free() const {
 
 
	return 0;
}



# 404 "/home/nando/archivos/trabajo/methodology/general.h" 2

	 
	 

	 

	
# 1 "/home/nando/archivos/trabajo/methodology/SC2eCos/sw_channels/uc_simple_channel_SS.h" 1
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 







# 1 "/home/nando/archivos/trabajo/methodology/SC2eCos/sw_channels/uc_channel_SS_base.h" 1
 
 
 
 
 
 
 
 
 
 
 
 







 
 
           

template<class T>
class uc_channel_SS_base {

public:

   
   
   

  uc_channel_SS_base() {
	 
	 
	 
	 
    cyg_flag_init(&channel_flag);

	 
     
     
    cyg_flag_setbits(&channel_flag,0x00000001);
    cyg_flag_maskbits(&channel_flag,0x00000001);    
	  
  }

protected:
		
  T data_container;
 
 
 
  cyg_flag_t   channel_flag;
 
   
   
   

};


# 27 "/home/nando/archivos/trabajo/methodology/SC2eCos/sw_channels/uc_simple_channel_SS.h" 2



 
 
           

 
 

template<class T>
class uc_simple_channel_SS : virtual public uc_channel_SS_base<T>,
 
 
 
              public uc_simple_read_write_if<T>
{

public:


  uc_simple_channel_SS(uc_module_name  name) {}

   
   
   

  void write(const T& data) {

    cyg_flag_wait(&channel_flag,0x1 ,((cyg_flag_mode_t)2) );
     
     
     
    cyg_flag_maskbits(&channel_flag,~0x1 );

     
    data_container = data;

    cyg_flag_setbits(&channel_flag,0x2 );         

  }


  void read(T& data) {


    cyg_flag_wait(&channel_flag,0x2 ,((cyg_flag_mode_t)2) );
     
     
     
    cyg_flag_maskbits(&channel_flag,~0x2 );

     
    data = data_container;

    cyg_flag_setbits(&channel_flag,0x1 );         

  }
  
  T& read() {
    read(data_container);
    return data_container;
  }
  
};


# 410 "/home/nando/archivos/trabajo/methodology/general.h" 2

	
# 1 "/home/nando/archivos/trabajo/methodology/SC2eCos/sw_channels/uc_nb_channel_SS.h" 1
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 







 
 
           

 
 
template<class T>
class uc_nb_channel_SS : virtual public uc_channel_SS_base<T>,
 
 
			  virtual public uc_nb_read_write_if<T>
{

public:

  uc_nb_channel_SS(uc_module_name  name) {;}

   
   
   

   
   

   
  void nb_write(const T& data) {

    cyg_flag_maskbits(&channel_flag,~0x1 );

     
    data_container = data;

     
    cyg_flag_setbits(&channel_flag,0x2 );         

  }

   
  void nb_read(T& data) {

    cyg_flag_maskbits(&channel_flag,~0x2 );

     
    data = data_container;

    cyg_flag_setbits(&channel_flag,0x1 );         

  }

};


# 411 "/home/nando/archivos/trabajo/methodology/general.h" 2

	
# 1 "/home/nando/archivos/trabajo/methodology/SC2eCos/sw_channels/uc_try_channel_SS.h" 1
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 






 
 
           

 
 

template<class T>
class uc_try_channel_SS : virtual public uc_channel_SS_base<T>,
 
 
			  virtual public uc_try_read_write_if<T>
{

public:

  uc_try_channel_SS(uc_module_name  name) {;}
   
   
   

   
  void try_write(const T& data) {

     
    if( cyg_flag_poll(&channel_flag,0x1 ,((cyg_flag_mode_t)2) ) != 0 ) {

       
       
       
      cyg_flag_maskbits(&channel_flag,~0x1 );

       
      data_container = data;

      cyg_flag_setbits(&channel_flag,0x2 );         
    }

  }

   
  void try_read(T& data) {
     
    if( cyg_flag_poll(&channel_flag,0x2 ,((cyg_flag_mode_t)2) ) != 0) {
       
       
       
      cyg_flag_maskbits(&channel_flag,~0x2 );

       
      data = data_container;

      cyg_flag_setbits(&channel_flag,0x1 );         
    }

  }

};


# 412 "/home/nando/archivos/trabajo/methodology/general.h" 2

	
# 1 "/home/nando/archivos/trabajo/methodology/SC2eCos/sw_channels/uc_extended_channel_SS.h" 1
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 




 
 
           
 
 




template<class T>
class uc_extended_channel_SS :
 
 
			  public uc_extended_read_write_if<T>,
              public uc_simple_channel_SS<T>,
              public uc_nb_channel_SS<T>,
              public uc_try_channel_SS<T>
{
public:
  uc_extended_channel_SS(uc_module_name  name): uc_simple_channel_SS<T>(name),
                                               uc_nb_channel_SS<T>(name),
                                               uc_try_channel_SS<T>(name) {}
};


# 413 "/home/nando/archivos/trabajo/methodology/general.h" 2


	 

	 

	 
	 
	
# 1 "/home/nando/archivos/trabajo/methodology/SC2eCos/sw_channels/uc_rv_uni_channel_SS.h" 1
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 








template<class T> 
class uc_rv_uni_channel_SS: 
            virtual public uc_simple_read_write_if<T>  {

public:				
	uc_rv_uni_channel_SS(const char *name=0);
				
	 
	void write(const T& data);

	 
    void read(T& data);
    T read();  

private:
	T			data_container;
	cyg_flag_t	channel_flag;


	cyg_mutex_t		writer_mutex;		 

};


template<class T> 
uc_rv_uni_channel_SS<T>::uc_rv_uni_channel_SS(const char *name) {


	 
    cyg_mutex_init(&writer_mutex);

	
 
 
 

	 
	 
     
	cyg_flag_init(&channel_flag);
    cyg_flag_maskbits(&channel_flag,0x00000000);   
}

template<class T> 
void uc_rv_uni_channel_SS<T>::write(const T& data) {


	 
	 
	cyg_mutex_lock(&writer_mutex);


	data_container = data;
	 
    cyg_flag_setbits(&channel_flag,0x1 );       

	 
 
     
     
     
 

	 
 

	 
	cyg_flag_wait(&channel_flag,0x2 ,((cyg_flag_mode_t)2) );
	cyg_flag_maskbits(&channel_flag,~0x2 );	


	 
	 
	cyg_mutex_unlock(&writer_mutex);


}

template<class T> 
void uc_rv_uni_channel_SS<T>::read(T& data) {

	 
  

	 
	cyg_flag_wait(&channel_flag,0x1 ,((cyg_flag_mode_t)2) );
     
     
     
    cyg_flag_maskbits(&channel_flag,~0x1 );

	data = data_container;

	 
	 
	 
	 
	
	 
	
	 
    cyg_flag_setbits(&channel_flag,0x2 );         

	 
 
 
}


template<class T> 
T uc_rv_uni_channel_SS<T>::read() {
	T tmpdata;
	read(tmpdata);
	return tmpdata;
}
	

# 421 "/home/nando/archivos/trabajo/methodology/general.h" 2

	
# 1 "/home/nando/archivos/trabajo/methodology/SC2eCos/sw_channels/uc_rv_sync_channel_SS.h" 1
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 







template<unsigned int NUMBER_OF_PROCESSES_IN_RV> 
class uc_rv_sync_channel_SS : 
            virtual public uc_sync_if {

public:				
	uc_rv_sync_channel_SS(const char *name=0);
				
	 
	void sync();

private:









	cyg_sem_t		sem;
	 
	cyg_mutex_t		channel_mutex;			 
	 
	cyg_flag_t		channel_flag;
	unsigned int	processes_in;
	unsigned int	processes_out;


};


# 97 "/home/nando/archivos/trabajo/methodology/SC2eCos/sw_channels/uc_rv_sync_channel_SS.h"




template<unsigned int NUMBER_OF_PROCESSES_IN_RV>
uc_rv_sync_channel_SS<NUMBER_OF_PROCESSES_IN_RV>::uc_rv_sync_channel_SS(const char *name) {

	 
	 
	processes_in=0;
	processes_out=0;
	 
	cyg_flag_init(&channel_flag);
	cyg_flag_maskbits(&channel_flag,0x00000000);  
	 
	cyg_mutex_init(&channel_mutex);
	 
	cyg_semaphore_init(&sem,NUMBER_OF_PROCESSES_IN_RV);
}

template<unsigned int NUMBER_OF_PROCESSES_IN_RV>
void uc_rv_sync_channel_SS<NUMBER_OF_PROCESSES_IN_RV>::sync() {
	 
	cyg_semaphore_wait(&sem);
	 
	
	 
	cyg_mutex_lock(&channel_mutex);

	processes_in++;
	
	if(processes_in<NUMBER_OF_PROCESSES_IN_RV) {
		 
		 
		cyg_mutex_unlock(&channel_mutex);
		 
		 
		 
		cyg_flag_wait(&channel_flag,0x1 ,((cyg_flag_mode_t)0) );
	} else {  
		cyg_flag_setbits(&channel_flag,0x1 );
		cyg_mutex_unlock(&channel_mutex);
	}
	 
	 
	 
	 
	 
	 
	cyg_mutex_lock(&channel_mutex);
	if (processes_out>=(NUMBER_OF_PROCESSES_IN_RV-1)) {
		 
		processes_in=0;
		processes_out=0;
		 
		cyg_flag_maskbits(&channel_flag,~0x1 );
		 
		cyg_semaphore_init(&sem,NUMBER_OF_PROCESSES_IN_RV);
	} else {
		processes_out++;
	}
	cyg_mutex_unlock(&channel_mutex);
}




# 422 "/home/nando/archivos/trabajo/methodology/general.h" 2


	 
	
# 1 "/home/nando/archivos/trabajo/methodology/SC2eCos/sw_channels/uc_fifo_channel_SS.h" 1
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 








template<class T>
class uc_fifo_channel_SS : public uc_fifo_if<T> {

public:

	 
				
	 
    uc_fifo_channel_SS(const char* name=0, unsigned int _size = 16);

	 
	void read(T& data);
	
	T read();

	bool nb_read(T& data);
	
	int num_available() const;
  
	 
  
	void write(const T& data);
	
	bool nb_write(const T& data);

	int num_free() const;


private:
	T 				*buffer;
	T				tmpdata;
	unsigned int 	write_index;
	unsigned int 	read_index;
	unsigned int	size;
	
	 
	cyg_sem_t		channel_sem;    
	 
	int	free_elements;				 
	cyg_flag_t		channel_flag;	 

	  

	cyg_mutex_t		writer_mutex;		 



	cyg_mutex_t		reader_mutex;		 

	 
 
	void reset();

};
 
 
 
 

template <class T>
inline uc_fifo_channel_SS<T>::uc_fifo_channel_SS(const char* name, unsigned int _size) {
     
     
     
    size = _size;
	reset();
	buffer = new T[size];
}

template <class T>
inline void uc_fifo_channel_SS<T>::reset() {
	write_index = 0;
	read_index = 0;
	cyg_semaphore_init(&channel_sem,size);
diag_printf ("Init fifo channel semaphore at size: %d\n",size);
	 
	 
	 
	 
	 
    cyg_flag_init(&channel_flag);	
    cyg_flag_maskbits(&channel_flag,0x00000000);   
	 
	

	cyg_mutex_init(&writer_mutex);



	cyg_mutex_init(&reader_mutex);

	
}


 
 






template <class T>
inline void uc_fifo_channel_SS<T>::read(T& data) {
diag_printf ("read 1\n");
     

	 
	 
	 
    cyg_mutex_lock(&reader_mutex);

diag_printf ("read 2\n");
	 
	cyg_flag_wait(&channel_flag,0x1 ,((cyg_flag_mode_t)2) );
	 
	 
	 
	 
	 
	 
	 
	 
	 
diag_printf ("read 3\n");	
	 
    data = buffer[read_index];

	 
    if(read_index>=size) 
		read_index=0;   
	else
		read_index++;
	
	cyg_semaphore_peek(&channel_sem,&free_elements);
	if((unsigned int)free_elements >= (size-1) )  
		cyg_flag_maskbits(&channel_flag,~0x1 );
diag_printf ("read 4\n");	

	cyg_mutex_unlock(&reader_mutex);

	
	 
	cyg_semaphore_post(&channel_sem);
	
}
  

template <class T>
inline T uc_fifo_channel_SS<T>::read() {
    read(tmpdata);
    return tmpdata;
}


template <class T>
inline bool uc_fifo_channel_SS<T>::nb_read(T& data) {
     

	 
	 
	 
    cyg_mutex_lock(&reader_mutex);


	 
	if(cyg_flag_poll(&channel_flag,0x1 ,((cyg_flag_mode_t)2) )) {
		 
		data = buffer[read_index];

		 
		if(read_index>=size) 
			read_index=0;   
		else
			read_index++;
	
		cyg_semaphore_peek(&channel_sem,&free_elements);
		if((unsigned int)free_elements>=(size-1))  
			cyg_flag_maskbits(&channel_flag,~0x1 );
	

		cyg_mutex_unlock(&reader_mutex);

		 
		cyg_semaphore_post(&channel_sem);
		
		return true;   

	} else {

		cyg_mutex_unlock(&reader_mutex);

		return false;
	}
}

template <class T>
inline int uc_fifo_channel_SS<T>::num_available() const {
 
 
	return 0;
}


template <class T>
inline void uc_fifo_channel_SS<T>::write(const T& data) {
diag_printf ("write 1\n");
	 
	cyg_semaphore_wait(&channel_sem);
diag_printf ("write 2\n");
	 
	 
	 

    cyg_mutex_lock(&writer_mutex);

diag_printf ("write 3\n");	
	 
    buffer[write_index] = data;

	 
    if(write_index>=size) 
		write_index=0;   
	else
		write_index++;
		 
	 
	cyg_flag_setbits(&channel_flag,0x1 );
diag_printf ("write 4\n");	

	cyg_mutex_unlock(&writer_mutex);

	
}

template <class T>
inline bool uc_fifo_channel_SS<T>::nb_write(const T& data) {
	 
	if(cyg_semaphore_trywait(&channel_sem)) {
		 
		 
		 

		cyg_mutex_lock(&writer_mutex);

	
		 
		buffer[write_index] = data;

		 
		if(write_index>=size) 
			write_index=0;   
		else
			write_index++;
			 
		 
		cyg_flag_setbits(&channel_flag,0x1 );
	

		cyg_mutex_unlock(&writer_mutex);

		return true;		
	} else {
		return false;
	}
}


template <class T>
inline int uc_fifo_channel_SS<T>::num_free() const {
 
 
	return 0;
}



# 425 "/home/nando/archivos/trabajo/methodology/general.h" 2

	 

	 
	 
	 
	 







 


 
 





 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 



 
 
 









# 85 "coder_tb.cc" 2


# 1 "../c_base/common/typedef.h" 1
 







# 80 "../c_base/common/typedef.h"


# 97 "../c_base/common/typedef.h"

typedef short Word16;
typedef int Word32;
typedef int Flag;




# 87 "coder_tb.cc" 2

# 1 "../c_base/common/cnst.h" 1



 
























 

static const Word16 F_gamma1[10 ] =
{
    29491, 26542, 23888, 21499, 19349,
    17414, 15672, 14105, 12694, 11425
};
static const Word16 F_gamma2[10 ] =
{
    19661, 11797, 7078, 4247, 2548,
    1529, 917, 550, 330, 198
};


# 88 "coder_tb.cc" 2

# 1 "../c_base/common/basic_op.h" 1
 




extern Flag Overflow;
extern Flag Carry;







 





Word16 add (Word16 var1, Word16 var2);     
Word16 sub (Word16 var1, Word16 var2);     
Word16 abs_s (Word16 var1);                
Word16 shl (Word16 var1, Word16 var2);     
Word16 shr (Word16 var1, Word16 var2);     
Word16 mult (Word16 var1, Word16 var2);    
Word32 L_mult (Word16 var1, Word16 var2);  
Word16 negate (Word16 var1);               
Word16 extract_h (Word32 L_var1);          
Word16 extract_l (Word32 L_var1);          
Word16 round (Word32 L_var1);              
Word32 L_mac (Word32 L_var3, Word16 var1, Word16 var2);    
Word32 L_msu (Word32 L_var3, Word16 var1, Word16 var2);    
Word32 L_macNs (Word32 L_var3, Word16 var1, Word16 var2);  

Word32 L_msuNs (Word32 L_var3, Word16 var1, Word16 var2);  

Word32 L_add (Word32 L_var1, Word32 L_var2);     
Word32 L_sub (Word32 L_var1, Word32 L_var2);     
Word32 L_add_c (Word32 L_var1, Word32 L_var2);   
Word32 L_sub_c (Word32 L_var1, Word32 L_var2);   
Word32 L_negate (Word32 L_var1);                 
Word16 mult_r (Word16 var1, Word16 var2);        
Word32 L_shl (Word32 L_var1, Word16 var2);       
Word32 L_shr (Word32 L_var1, Word16 var2);       
Word16 shr_r (Word16 var1, Word16 var2);         

Word16 mac_r (Word32 L_var3, Word16 var1, Word16 var2);  

Word16 msu_r (Word32 L_var3, Word16 var1, Word16 var2);  

Word32 L_deposit_h (Word16 var1);         
Word32 L_deposit_l (Word16 var1);         

Word32 L_shr_r (Word32 L_var1, Word16 var2);  

Word32 L_abs (Word32 L_var1);             
Word32 L_sat (Word32 L_var1);             
Word16 norm_s (Word16 var1);              
Word16 div_s (Word16 var1, Word16 var2);  
Word16 norm_l (Word32 L_var1);               

# 89 "coder_tb.cc" 2

# 1 "../c_base/common/sig_proc.h" 1
 



 

Word32 Inv_sqrt (       
    Word32 L_x          
);
void Log2 (
    Word32 L_x,         
    Word16 *exponent,   
    Word16 *fraction    
);
Word32 Pow2 (           
    Word16 exponent,    
    Word16 fraction     
);

 

void Init_Pre_Process (void);
void Pre_Process (
    Word16 signal[],    
    Word16 lg           
);

Word16 Autocorr (
    Word16 x[],         
    Word16 m,           
    Word16 r_h[],       
    Word16 r_l[],       
    const Word16 wind[] 
);
void Lag_window (
    Word16 m,           
    Word16 r_h[],       
    Word16 r_l[]        
);
void Levinson (
    Word16 Rh[],        
    Word16 Rl[],        
	Word16 old_A[],
    Word16 A[],         
    Word16 rc[]         
);
void Az_lsp (
    Word16 a[],         
    Word16 lsp[],       
    Word16 old_lsp[]    
);
void Lsp_Az (
    Word16 lsp[],       
    Word16 a[]          
);
void Lsf_lsp (
    Word16 lsf[],       
    Word16 lsp[],       
    Word16 m            
);
void Lsp_lsf (
    Word16 lsp[],       
    Word16 lsf[],       
    Word16 m            
);
void Reorder_lsf (
    Word16 *lsf,        
    Word16 min_dist,    
    Word16 n            
);
void Weight_Fac (
    Word16 gamma,       
    Word16 fac[]        
);
void Weight_Ai (
    Word16 a[],         
    const Word16 fac[], 
    Word16 a_exp[]      
);
void Residu (
    Word16 a[],         
    Word16 x[],         
    Word16 y[],         
    Word16 lg           
);
void Syn_filt (
    Word16 a[],         
    Word16 x[],         
    Word16 y[],         
    Word16 lg,          
    Word16 mem[],       
    Word16 update       
);
void Convolve (
    Word16 x[],         
    Word16 h[],         
    Word16 y[],         
    Word16 L            
);
void agc (
    Word16 *sig_in,     
    Word16 *sig_out,    
    Word16 agc_fac,     
    Word16 l_trm        
);
void agc2 (
    Word16 *sig_in,     
    Word16 *sig_out,    
    Word16 l_trm        
);
void preemphasis (
    Word16 *signal,     
    Word16 g,           
    Word16 L            
);

 

void Copy (
    Word16 x[],         
    Word16 y[],         
    Word16 L            
);
void Set_zero (
    Word16 x[],         
    Word16 L            
);
# 90 "coder_tb.cc" 2



 
 
 

 



# 1 "/home/nando/archivos/trabajo/methodology/sw_section.h" 1
 
 
 
 
 
 
 
 
 
 
 
 










 
 
 
 
 

 
 
 
 
 

 

 
 
 


 
 

 




 







 

 




 
 
 
 
 
 
 

# 101 "coder_tb.cc" 2

 
# 1 "coder_env.cc" 1
 
 
 
 
 
 
 
 
 
 

 







struct   coder_env   :public uc_module   {
public:
	uc_port <sc_fifo_out_if<bool> >	dtx_mode_out;
	 
	uc_port <sc_fifo_out_if<Word16> >	sample_out;
	 
	uc_port <sc_fifo_in_if<bool> >	serial_coded_prm;
	
	void PCMStream_gen();
	void RadioSubSystem();  
	
	typedef   coder_env   UC_CURRENT_USER_MODULE;   coder_env  (uc_module_name)   {
		execution_context.register_thread_process( static_cast<UC_ENTRY_FUNC> (&   UC_CURRENT_USER_MODULE  ::     PCMStream_gen     ) , this, "PCMStream_gen",8192 )   ;
		execution_context.register_thread_process( static_cast<UC_ENTRY_FUNC> (&   UC_CURRENT_USER_MODULE  ::     RadioSubSystem     ) , this, "RadioSubSystem",8192 )   ;
 
 
 
	}
	
};

# 186 "coder_env.cc"




 
 
 






 

 
 







 



# 227 "coder_env.cc"





 
int rom_ns_array[320 ];
Word16 rom_serial_cod_array[492 ];

 
 
 
 
 
 
 
 

void coder_env::PCMStream_gen() {
	

diag_printf ("CODER_ENV: PCMStream_gen: START\n");

	
	int i;
	Word16 j;
	Word16 frame;
	
	Word16 dtx_mode;

*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x94000008 =0x0; ;*(unsigned int *)0x9400000C =0x1; ; ;
	
 
 






 
# 1 "../HW/HW_test/rom_ns_content2.h" 1
rom_ns_array[0]=8;
rom_ns_array[1]=8;
rom_ns_array[2]=8;
rom_ns_array[3]=8;
rom_ns_array[4]=8;
rom_ns_array[5]=8;
rom_ns_array[6]=8;
rom_ns_array[7]=8;
rom_ns_array[8]=8;
rom_ns_array[9]=8;
rom_ns_array[10]=8;
rom_ns_array[11]=8;
rom_ns_array[12]=8;
rom_ns_array[13]=8;
rom_ns_array[14]=8;
rom_ns_array[15]=8;
rom_ns_array[16]=8;
rom_ns_array[17]=8;
rom_ns_array[18]=8;
rom_ns_array[19]=8;
rom_ns_array[20]=8;
rom_ns_array[21]=8;
rom_ns_array[22]=8;
rom_ns_array[23]=8;
rom_ns_array[24]=8;
rom_ns_array[25]=8;
rom_ns_array[26]=8;
rom_ns_array[27]=8;
rom_ns_array[28]=8;
rom_ns_array[29]=8;
rom_ns_array[30]=8;
rom_ns_array[31]=8;
rom_ns_array[32]=8;
rom_ns_array[33]=8;
rom_ns_array[34]=8;
rom_ns_array[35]=8;
rom_ns_array[36]=8;
rom_ns_array[37]=8;
rom_ns_array[38]=8;
rom_ns_array[39]=8;
rom_ns_array[40]=8;
rom_ns_array[41]=8;
rom_ns_array[42]=8;
rom_ns_array[43]=8;
rom_ns_array[44]=8;
rom_ns_array[45]=8;
rom_ns_array[46]=8;
rom_ns_array[47]=8;
rom_ns_array[48]=8;
rom_ns_array[49]=8;
rom_ns_array[50]=8;
rom_ns_array[51]=8;
rom_ns_array[52]=8;
rom_ns_array[53]=8;
rom_ns_array[54]=8;
rom_ns_array[55]=8;
rom_ns_array[56]=8;
rom_ns_array[57]=8;
rom_ns_array[58]=8;
rom_ns_array[59]=8;
rom_ns_array[60]=8;
rom_ns_array[61]=8;
rom_ns_array[62]=8;
rom_ns_array[63]=8;
rom_ns_array[64]=8;
rom_ns_array[65]=8;
rom_ns_array[66]=8;
rom_ns_array[67]=8;
rom_ns_array[68]=8;
rom_ns_array[69]=8;
rom_ns_array[70]=8;
rom_ns_array[71]=8;
rom_ns_array[72]=8;
rom_ns_array[73]=8;
rom_ns_array[74]=8;
rom_ns_array[75]=8;
rom_ns_array[76]=8;
rom_ns_array[77]=8;
rom_ns_array[78]=8;
rom_ns_array[79]=8;
rom_ns_array[80]=8;
rom_ns_array[81]=8;
rom_ns_array[82]=8;
rom_ns_array[83]=8;
rom_ns_array[84]=8;
rom_ns_array[85]=8;
rom_ns_array[86]=8;
rom_ns_array[87]=8;
rom_ns_array[88]=8;
rom_ns_array[89]=8;
rom_ns_array[90]=8;
rom_ns_array[91]=8;
rom_ns_array[92]=8;
rom_ns_array[93]=8;
rom_ns_array[94]=8;
rom_ns_array[95]=8;
rom_ns_array[96]=8;
rom_ns_array[97]=8;
rom_ns_array[98]=8;
rom_ns_array[99]=8;
rom_ns_array[100]=8;
rom_ns_array[101]=8;
rom_ns_array[102]=8;
rom_ns_array[103]=8;
rom_ns_array[104]=8;
rom_ns_array[105]=8;
rom_ns_array[106]=8;
rom_ns_array[107]=8;
rom_ns_array[108]=8;
rom_ns_array[109]=8;
rom_ns_array[110]=8;
rom_ns_array[111]=8;
rom_ns_array[112]=8;
rom_ns_array[113]=8;
rom_ns_array[114]=8;
rom_ns_array[115]=8;
rom_ns_array[116]=8;
rom_ns_array[117]=8;
rom_ns_array[118]=8;
rom_ns_array[119]=8;
rom_ns_array[120]=8;
rom_ns_array[121]=8;
rom_ns_array[122]=8;
rom_ns_array[123]=8;
rom_ns_array[124]=8;
rom_ns_array[125]=8;
rom_ns_array[126]=8;
rom_ns_array[127]=8;
rom_ns_array[128]=8;
rom_ns_array[129]=8;
rom_ns_array[130]=8;
rom_ns_array[131]=8;
rom_ns_array[132]=8;
rom_ns_array[133]=8;
rom_ns_array[134]=8;
rom_ns_array[135]=8;
rom_ns_array[136]=8;
rom_ns_array[137]=8;
rom_ns_array[138]=8;
rom_ns_array[139]=8;
rom_ns_array[140]=8;
rom_ns_array[141]=8;
rom_ns_array[142]=8;
rom_ns_array[143]=8;
rom_ns_array[144]=8;
rom_ns_array[145]=8;
rom_ns_array[146]=8;
rom_ns_array[147]=8;
rom_ns_array[148]=8;
rom_ns_array[149]=8;
rom_ns_array[150]=8;
rom_ns_array[151]=8;
rom_ns_array[152]=8;
rom_ns_array[153]=8;
rom_ns_array[154]=8;
rom_ns_array[155]=8;
rom_ns_array[156]=8;
rom_ns_array[157]=8;
rom_ns_array[158]=8;
rom_ns_array[159]=8;
rom_ns_array[160]=8;
rom_ns_array[161]=8;
rom_ns_array[162]=8;
rom_ns_array[163]=8;
rom_ns_array[164]=8;
rom_ns_array[165]=8;
rom_ns_array[166]=8;
rom_ns_array[167]=8;
rom_ns_array[168]=8;
rom_ns_array[169]=8;
rom_ns_array[170]=8;
rom_ns_array[171]=8;
rom_ns_array[172]=8;
rom_ns_array[173]=8;
rom_ns_array[174]=8;
rom_ns_array[175]=8;
rom_ns_array[176]=8;
rom_ns_array[177]=8;
rom_ns_array[178]=8;
rom_ns_array[179]=8;
rom_ns_array[180]=8;
rom_ns_array[181]=8;
rom_ns_array[182]=8;
rom_ns_array[183]=8;
rom_ns_array[184]=8;
rom_ns_array[185]=8;
rom_ns_array[186]=8;
rom_ns_array[187]=8;
rom_ns_array[188]=8;
rom_ns_array[189]=8;
rom_ns_array[190]=8;
rom_ns_array[191]=8;
rom_ns_array[192]=8;
rom_ns_array[193]=8;
rom_ns_array[194]=8;
rom_ns_array[195]=8;
rom_ns_array[196]=8;
rom_ns_array[197]=8;
rom_ns_array[198]=8;
rom_ns_array[199]=8;
rom_ns_array[200]=8;
rom_ns_array[201]=8;
rom_ns_array[202]=8;
rom_ns_array[203]=8;
rom_ns_array[204]=8;
rom_ns_array[205]=8;
rom_ns_array[206]=8;
rom_ns_array[207]=8;
rom_ns_array[208]=8;
rom_ns_array[209]=8;
rom_ns_array[210]=8;
rom_ns_array[211]=8;
rom_ns_array[212]=8;
rom_ns_array[213]=8;
rom_ns_array[214]=8;
rom_ns_array[215]=8;
rom_ns_array[216]=8;
rom_ns_array[217]=8;
rom_ns_array[218]=8;
rom_ns_array[219]=8;
rom_ns_array[220]=8;
rom_ns_array[221]=8;
rom_ns_array[222]=8;
rom_ns_array[223]=8;
rom_ns_array[224]=8;
rom_ns_array[225]=8;
rom_ns_array[226]=8;
rom_ns_array[227]=8;
rom_ns_array[228]=8;
rom_ns_array[229]=8;
rom_ns_array[230]=8;
rom_ns_array[231]=8;
rom_ns_array[232]=8;
rom_ns_array[233]=8;
rom_ns_array[234]=8;
rom_ns_array[235]=8;
rom_ns_array[236]=8;
rom_ns_array[237]=8;
rom_ns_array[238]=8;
rom_ns_array[239]=8;
rom_ns_array[240]=8;
rom_ns_array[241]=8;
rom_ns_array[242]=8;
rom_ns_array[243]=8;
rom_ns_array[244]=8;
rom_ns_array[245]=8;
rom_ns_array[246]=8;
rom_ns_array[247]=8;
rom_ns_array[248]=8;
rom_ns_array[249]=8;
rom_ns_array[250]=8;
rom_ns_array[251]=8;
rom_ns_array[252]=8;
rom_ns_array[253]=8;
rom_ns_array[254]=8;
rom_ns_array[255]=8;
rom_ns_array[256]=8;
rom_ns_array[257]=8;
rom_ns_array[258]=8;
rom_ns_array[259]=8;
rom_ns_array[260]=8;
rom_ns_array[261]=8;
rom_ns_array[262]=8;
rom_ns_array[263]=8;
rom_ns_array[264]=8;
rom_ns_array[265]=8;
rom_ns_array[266]=8;
rom_ns_array[267]=8;
rom_ns_array[268]=8;
rom_ns_array[269]=8;
rom_ns_array[270]=8;
rom_ns_array[271]=8;
rom_ns_array[272]=8;
rom_ns_array[273]=8;
rom_ns_array[274]=8;
rom_ns_array[275]=8;
rom_ns_array[276]=8;
rom_ns_array[277]=8;
rom_ns_array[278]=8;
rom_ns_array[279]=8;
rom_ns_array[280]=8;
rom_ns_array[281]=8;
rom_ns_array[282]=8;
rom_ns_array[283]=8;
rom_ns_array[284]=8;
rom_ns_array[285]=8;
rom_ns_array[286]=8;
rom_ns_array[287]=8;
rom_ns_array[288]=8;
rom_ns_array[289]=8;
rom_ns_array[290]=8;
rom_ns_array[291]=8;
rom_ns_array[292]=8;
rom_ns_array[293]=8;
rom_ns_array[294]=8;
rom_ns_array[295]=8;
rom_ns_array[296]=8;
rom_ns_array[297]=8;
rom_ns_array[298]=8;
rom_ns_array[299]=8;
rom_ns_array[300]=8;
rom_ns_array[301]=8;
rom_ns_array[302]=8;
rom_ns_array[303]=8;
rom_ns_array[304]=8;
rom_ns_array[305]=8;
rom_ns_array[306]=8;
rom_ns_array[307]=8;
rom_ns_array[308]=8;
rom_ns_array[309]=8;
rom_ns_array[310]=8;
rom_ns_array[311]=8;
rom_ns_array[312]=8;
rom_ns_array[313]=8;
rom_ns_array[314]=8;
rom_ns_array[315]=8;
rom_ns_array[316]=8;
rom_ns_array[317]=8;
rom_ns_array[318]=8;
rom_ns_array[319]=8;
# 268 "coder_env.cc" 2

	








	
    dtx_mode = 0;	 

	 
	{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  dtx_mode_out->write((bool)dtx_mode);  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}  
	
	frame = 0;
	j=0;

	 
 
	{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  dtx_mode_out->write(0 );  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}  
	for(i=0;i< 320 ;i++) {
		{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  sample_out->write((Word16)rom_ns_array[i]);  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}  
		if(j<159) {
			j++;
		}
		else {
			j=0;
			frame++;




			diag_printf ("Frame %d sent.\n", frame);


		}
# 318 "coder_env.cc"

	}
	
}
	

 
 
 
 
 
 
 
void coder_env::RadioSubSystem() {  
	

diag_printf ("CODER_ENV: RadioSubSystem: START\n");

	


	*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.show_results();*(unsigned int *)0x9400000C =0x1; ; ;


	
	bool match;
	
	bool rec_bit;
	
	Word16 i;
	int index;
	Word16 frame;
	







	
 

*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x94000008 =0x0; ;*(unsigned int *)0x9400000C =0x1; ; ;	
	





 
# 1 "../HW/HW_test/rom_serial_cod_content2.h" 1
rom_serial_cod_array[0]=0;
rom_serial_cod_array[1]=0;
rom_serial_cod_array[2]=0;
rom_serial_cod_array[3]=0;
rom_serial_cod_array[4]=1;
rom_serial_cod_array[5]=0;
rom_serial_cod_array[6]=0;
rom_serial_cod_array[7]=0;
rom_serial_cod_array[8]=0;
rom_serial_cod_array[9]=1;
rom_serial_cod_array[10]=0;
rom_serial_cod_array[11]=1;
rom_serial_cod_array[12]=1;
rom_serial_cod_array[13]=1;
rom_serial_cod_array[14]=1;
rom_serial_cod_array[15]=0;
rom_serial_cod_array[16]=1;
rom_serial_cod_array[17]=0;
rom_serial_cod_array[18]=1;
rom_serial_cod_array[19]=1;
rom_serial_cod_array[20]=0;
rom_serial_cod_array[21]=1;
rom_serial_cod_array[22]=0;
rom_serial_cod_array[23]=0;
rom_serial_cod_array[24]=1;
rom_serial_cod_array[25]=0;
rom_serial_cod_array[26]=0;
rom_serial_cod_array[27]=1;
rom_serial_cod_array[28]=0;
rom_serial_cod_array[29]=0;
rom_serial_cod_array[30]=0;
rom_serial_cod_array[31]=0;
rom_serial_cod_array[32]=1;
rom_serial_cod_array[33]=1;
rom_serial_cod_array[34]=1;
rom_serial_cod_array[35]=1;
rom_serial_cod_array[36]=1;
rom_serial_cod_array[37]=0;
rom_serial_cod_array[38]=1;
rom_serial_cod_array[39]=0;
rom_serial_cod_array[40]=1;
rom_serial_cod_array[41]=0;
rom_serial_cod_array[42]=1;
rom_serial_cod_array[43]=0;
rom_serial_cod_array[44]=1;
rom_serial_cod_array[45]=1;
rom_serial_cod_array[46]=0;
rom_serial_cod_array[47]=1;
rom_serial_cod_array[48]=0;
rom_serial_cod_array[49]=1;
rom_serial_cod_array[50]=1;
rom_serial_cod_array[51]=0;
rom_serial_cod_array[52]=0;
rom_serial_cod_array[53]=0;
rom_serial_cod_array[54]=0;
rom_serial_cod_array[55]=0;
rom_serial_cod_array[56]=0;
rom_serial_cod_array[57]=0;
rom_serial_cod_array[58]=1;
rom_serial_cod_array[59]=1;
rom_serial_cod_array[60]=1;
rom_serial_cod_array[61]=1;
rom_serial_cod_array[62]=1;
rom_serial_cod_array[63]=0;
rom_serial_cod_array[64]=0;
rom_serial_cod_array[65]=0;
rom_serial_cod_array[66]=1;
rom_serial_cod_array[67]=1;
rom_serial_cod_array[68]=1;
rom_serial_cod_array[69]=0;
rom_serial_cod_array[70]=1;
rom_serial_cod_array[71]=0;
rom_serial_cod_array[72]=0;
rom_serial_cod_array[73]=0;
rom_serial_cod_array[74]=0;
rom_serial_cod_array[75]=1;
rom_serial_cod_array[76]=1;
rom_serial_cod_array[77]=0;
rom_serial_cod_array[78]=0;
rom_serial_cod_array[79]=0;
rom_serial_cod_array[80]=0;
rom_serial_cod_array[81]=1;
rom_serial_cod_array[82]=1;
rom_serial_cod_array[83]=0;
rom_serial_cod_array[84]=0;
rom_serial_cod_array[85]=0;
rom_serial_cod_array[86]=0;
rom_serial_cod_array[87]=0;
rom_serial_cod_array[88]=0;
rom_serial_cod_array[89]=1;
rom_serial_cod_array[90]=1;
rom_serial_cod_array[91]=1;
rom_serial_cod_array[92]=1;
rom_serial_cod_array[93]=0;
rom_serial_cod_array[94]=1;
rom_serial_cod_array[95]=1;
rom_serial_cod_array[96]=0;
rom_serial_cod_array[97]=0;
rom_serial_cod_array[98]=0;
rom_serial_cod_array[99]=0;
rom_serial_cod_array[100]=1;
rom_serial_cod_array[101]=1;
rom_serial_cod_array[102]=0;
rom_serial_cod_array[103]=0;
rom_serial_cod_array[104]=0;
rom_serial_cod_array[105]=1;
rom_serial_cod_array[106]=0;
rom_serial_cod_array[107]=0;
rom_serial_cod_array[108]=0;
rom_serial_cod_array[109]=0;
rom_serial_cod_array[110]=1;
rom_serial_cod_array[111]=0;
rom_serial_cod_array[112]=1;
rom_serial_cod_array[113]=1;
rom_serial_cod_array[114]=0;
rom_serial_cod_array[115]=0;
rom_serial_cod_array[116]=0;
rom_serial_cod_array[117]=0;
rom_serial_cod_array[118]=0;
rom_serial_cod_array[119]=0;
rom_serial_cod_array[120]=1;
rom_serial_cod_array[121]=0;
rom_serial_cod_array[122]=0;
rom_serial_cod_array[123]=0;
rom_serial_cod_array[124]=0;
rom_serial_cod_array[125]=0;
rom_serial_cod_array[126]=0;
rom_serial_cod_array[127]=0;
rom_serial_cod_array[128]=0;
rom_serial_cod_array[129]=1;
rom_serial_cod_array[130]=0;
rom_serial_cod_array[131]=0;
rom_serial_cod_array[132]=1;
rom_serial_cod_array[133]=0;
rom_serial_cod_array[134]=0;
rom_serial_cod_array[135]=0;
rom_serial_cod_array[136]=0;
rom_serial_cod_array[137]=0;
rom_serial_cod_array[138]=0;
rom_serial_cod_array[139]=0;
rom_serial_cod_array[140]=0;
rom_serial_cod_array[141]=1;
rom_serial_cod_array[142]=0;
rom_serial_cod_array[143]=1;
rom_serial_cod_array[144]=0;
rom_serial_cod_array[145]=1;
rom_serial_cod_array[146]=0;
rom_serial_cod_array[147]=1;
rom_serial_cod_array[148]=1;
rom_serial_cod_array[149]=0;
rom_serial_cod_array[150]=0;
rom_serial_cod_array[151]=0;
rom_serial_cod_array[152]=0;
rom_serial_cod_array[153]=0;
rom_serial_cod_array[154]=0;
rom_serial_cod_array[155]=0;
rom_serial_cod_array[156]=0;
rom_serial_cod_array[157]=0;
rom_serial_cod_array[158]=0;
rom_serial_cod_array[159]=0;
rom_serial_cod_array[160]=0;
rom_serial_cod_array[161]=0;
rom_serial_cod_array[162]=0;
rom_serial_cod_array[163]=0;
rom_serial_cod_array[164]=0;
rom_serial_cod_array[165]=0;
rom_serial_cod_array[166]=0;
rom_serial_cod_array[167]=0;
rom_serial_cod_array[168]=0;
rom_serial_cod_array[169]=0;
rom_serial_cod_array[170]=0;
rom_serial_cod_array[171]=0;
rom_serial_cod_array[172]=0;
rom_serial_cod_array[173]=0;
rom_serial_cod_array[174]=0;
rom_serial_cod_array[175]=0;
rom_serial_cod_array[176]=0;
rom_serial_cod_array[177]=0;
rom_serial_cod_array[178]=0;
rom_serial_cod_array[179]=0;
rom_serial_cod_array[180]=0;
rom_serial_cod_array[181]=0;
rom_serial_cod_array[182]=0;
rom_serial_cod_array[183]=0;
rom_serial_cod_array[184]=0;
rom_serial_cod_array[185]=0;
rom_serial_cod_array[186]=0;
rom_serial_cod_array[187]=0;
rom_serial_cod_array[188]=0;
rom_serial_cod_array[189]=0;
rom_serial_cod_array[190]=0;
rom_serial_cod_array[191]=0;
rom_serial_cod_array[192]=0;
rom_serial_cod_array[193]=0;
rom_serial_cod_array[194]=1;
rom_serial_cod_array[195]=1;
rom_serial_cod_array[196]=0;
rom_serial_cod_array[197]=1;
rom_serial_cod_array[198]=1;
rom_serial_cod_array[199]=0;
rom_serial_cod_array[200]=1;
rom_serial_cod_array[201]=0;
rom_serial_cod_array[202]=1;
rom_serial_cod_array[203]=1;
rom_serial_cod_array[204]=0;
rom_serial_cod_array[205]=0;
rom_serial_cod_array[206]=0;
rom_serial_cod_array[207]=0;
rom_serial_cod_array[208]=0;
rom_serial_cod_array[209]=0;
rom_serial_cod_array[210]=0;
rom_serial_cod_array[211]=0;
rom_serial_cod_array[212]=0;
rom_serial_cod_array[213]=0;
rom_serial_cod_array[214]=0;
rom_serial_cod_array[215]=0;
rom_serial_cod_array[216]=0;
rom_serial_cod_array[217]=0;
rom_serial_cod_array[218]=0;
rom_serial_cod_array[219]=0;
rom_serial_cod_array[220]=0;
rom_serial_cod_array[221]=0;
rom_serial_cod_array[222]=0;
rom_serial_cod_array[223]=0;
rom_serial_cod_array[224]=0;
rom_serial_cod_array[225]=0;
rom_serial_cod_array[226]=0;
rom_serial_cod_array[227]=0;
rom_serial_cod_array[228]=0;
rom_serial_cod_array[229]=0;
rom_serial_cod_array[230]=0;
rom_serial_cod_array[231]=0;
rom_serial_cod_array[232]=0;
rom_serial_cod_array[233]=0;
rom_serial_cod_array[234]=0;
rom_serial_cod_array[235]=0;
rom_serial_cod_array[236]=0;
rom_serial_cod_array[237]=0;
rom_serial_cod_array[238]=0;
rom_serial_cod_array[239]=0;
rom_serial_cod_array[240]=0;
rom_serial_cod_array[241]=0;
rom_serial_cod_array[242]=0;
rom_serial_cod_array[243]=0;
rom_serial_cod_array[244]=1;
rom_serial_cod_array[245]=1;
rom_serial_cod_array[246]=0;
rom_serial_cod_array[247]=0;
rom_serial_cod_array[248]=0;
rom_serial_cod_array[249]=0;
rom_serial_cod_array[250]=1;
rom_serial_cod_array[251]=0;
rom_serial_cod_array[252]=0;
rom_serial_cod_array[253]=0;
rom_serial_cod_array[254]=0;
rom_serial_cod_array[255]=1;
rom_serial_cod_array[256]=0;
rom_serial_cod_array[257]=1;
rom_serial_cod_array[258]=1;
rom_serial_cod_array[259]=1;
rom_serial_cod_array[260]=1;
rom_serial_cod_array[261]=0;
rom_serial_cod_array[262]=1;
rom_serial_cod_array[263]=0;
rom_serial_cod_array[264]=1;
rom_serial_cod_array[265]=1;
rom_serial_cod_array[266]=0;
rom_serial_cod_array[267]=1;
rom_serial_cod_array[268]=0;
rom_serial_cod_array[269]=0;
rom_serial_cod_array[270]=1;
rom_serial_cod_array[271]=0;
rom_serial_cod_array[272]=0;
rom_serial_cod_array[273]=1;
rom_serial_cod_array[274]=0;
rom_serial_cod_array[275]=0;
rom_serial_cod_array[276]=0;
rom_serial_cod_array[277]=0;
rom_serial_cod_array[278]=1;
rom_serial_cod_array[279]=1;
rom_serial_cod_array[280]=1;
rom_serial_cod_array[281]=1;
rom_serial_cod_array[282]=1;
rom_serial_cod_array[283]=0;
rom_serial_cod_array[284]=1;
rom_serial_cod_array[285]=0;
rom_serial_cod_array[286]=1;
rom_serial_cod_array[287]=0;
rom_serial_cod_array[288]=1;
rom_serial_cod_array[289]=0;
rom_serial_cod_array[290]=1;
rom_serial_cod_array[291]=1;
rom_serial_cod_array[292]=0;
rom_serial_cod_array[293]=1;
rom_serial_cod_array[294]=0;
rom_serial_cod_array[295]=1;
rom_serial_cod_array[296]=1;
rom_serial_cod_array[297]=0;
rom_serial_cod_array[298]=0;
rom_serial_cod_array[299]=0;
rom_serial_cod_array[300]=0;
rom_serial_cod_array[301]=0;
rom_serial_cod_array[302]=0;
rom_serial_cod_array[303]=0;
rom_serial_cod_array[304]=1;
rom_serial_cod_array[305]=1;
rom_serial_cod_array[306]=1;
rom_serial_cod_array[307]=1;
rom_serial_cod_array[308]=1;
rom_serial_cod_array[309]=0;
rom_serial_cod_array[310]=0;
rom_serial_cod_array[311]=0;
rom_serial_cod_array[312]=1;
rom_serial_cod_array[313]=1;
rom_serial_cod_array[314]=1;
rom_serial_cod_array[315]=0;
rom_serial_cod_array[316]=1;
rom_serial_cod_array[317]=0;
rom_serial_cod_array[318]=0;
rom_serial_cod_array[319]=0;
rom_serial_cod_array[320]=0;
rom_serial_cod_array[321]=1;
rom_serial_cod_array[322]=1;
rom_serial_cod_array[323]=0;
rom_serial_cod_array[324]=0;
rom_serial_cod_array[325]=0;
rom_serial_cod_array[326]=0;
rom_serial_cod_array[327]=1;
rom_serial_cod_array[328]=1;
rom_serial_cod_array[329]=0;
rom_serial_cod_array[330]=0;
rom_serial_cod_array[331]=0;
rom_serial_cod_array[332]=0;
rom_serial_cod_array[333]=0;
rom_serial_cod_array[334]=0;
rom_serial_cod_array[335]=1;
rom_serial_cod_array[336]=1;
rom_serial_cod_array[337]=1;
rom_serial_cod_array[338]=1;
rom_serial_cod_array[339]=0;
rom_serial_cod_array[340]=1;
rom_serial_cod_array[341]=1;
rom_serial_cod_array[342]=0;
rom_serial_cod_array[343]=0;
rom_serial_cod_array[344]=0;
rom_serial_cod_array[345]=0;
rom_serial_cod_array[346]=1;
rom_serial_cod_array[347]=1;
rom_serial_cod_array[348]=0;
rom_serial_cod_array[349]=0;
rom_serial_cod_array[350]=0;
rom_serial_cod_array[351]=1;
rom_serial_cod_array[352]=0;
rom_serial_cod_array[353]=0;
rom_serial_cod_array[354]=0;
rom_serial_cod_array[355]=0;
rom_serial_cod_array[356]=1;
rom_serial_cod_array[357]=0;
rom_serial_cod_array[358]=1;
rom_serial_cod_array[359]=1;
rom_serial_cod_array[360]=0;
rom_serial_cod_array[361]=0;
rom_serial_cod_array[362]=0;
rom_serial_cod_array[363]=0;
rom_serial_cod_array[364]=0;
rom_serial_cod_array[365]=0;
rom_serial_cod_array[366]=1;
rom_serial_cod_array[367]=0;
rom_serial_cod_array[368]=0;
rom_serial_cod_array[369]=0;
rom_serial_cod_array[370]=0;
rom_serial_cod_array[371]=0;
rom_serial_cod_array[372]=0;
rom_serial_cod_array[373]=0;
rom_serial_cod_array[374]=0;
rom_serial_cod_array[375]=1;
rom_serial_cod_array[376]=0;
rom_serial_cod_array[377]=0;
rom_serial_cod_array[378]=1;
rom_serial_cod_array[379]=0;
rom_serial_cod_array[380]=0;
rom_serial_cod_array[381]=0;
rom_serial_cod_array[382]=0;
rom_serial_cod_array[383]=0;
rom_serial_cod_array[384]=0;
rom_serial_cod_array[385]=0;
rom_serial_cod_array[386]=0;
rom_serial_cod_array[387]=1;
rom_serial_cod_array[388]=0;
rom_serial_cod_array[389]=1;
rom_serial_cod_array[390]=0;
rom_serial_cod_array[391]=1;
rom_serial_cod_array[392]=0;
rom_serial_cod_array[393]=1;
rom_serial_cod_array[394]=1;
rom_serial_cod_array[395]=0;
rom_serial_cod_array[396]=0;
rom_serial_cod_array[397]=0;
rom_serial_cod_array[398]=0;
rom_serial_cod_array[399]=0;
rom_serial_cod_array[400]=0;
rom_serial_cod_array[401]=0;
rom_serial_cod_array[402]=0;
rom_serial_cod_array[403]=0;
rom_serial_cod_array[404]=0;
rom_serial_cod_array[405]=0;
rom_serial_cod_array[406]=0;
rom_serial_cod_array[407]=0;
rom_serial_cod_array[408]=0;
rom_serial_cod_array[409]=0;
rom_serial_cod_array[410]=0;
rom_serial_cod_array[411]=0;
rom_serial_cod_array[412]=0;
rom_serial_cod_array[413]=0;
rom_serial_cod_array[414]=0;
rom_serial_cod_array[415]=0;
rom_serial_cod_array[416]=0;
rom_serial_cod_array[417]=0;
rom_serial_cod_array[418]=0;
rom_serial_cod_array[419]=0;
rom_serial_cod_array[420]=0;
rom_serial_cod_array[421]=0;
rom_serial_cod_array[422]=0;
rom_serial_cod_array[423]=0;
rom_serial_cod_array[424]=0;
rom_serial_cod_array[425]=0;
rom_serial_cod_array[426]=0;
rom_serial_cod_array[427]=0;
rom_serial_cod_array[428]=0;
rom_serial_cod_array[429]=0;
rom_serial_cod_array[430]=0;
rom_serial_cod_array[431]=0;
rom_serial_cod_array[432]=0;
rom_serial_cod_array[433]=0;
rom_serial_cod_array[434]=0;
rom_serial_cod_array[435]=0;
rom_serial_cod_array[436]=0;
rom_serial_cod_array[437]=0;
rom_serial_cod_array[438]=0;
rom_serial_cod_array[439]=0;
rom_serial_cod_array[440]=1;
rom_serial_cod_array[441]=1;
rom_serial_cod_array[442]=0;
rom_serial_cod_array[443]=1;
rom_serial_cod_array[444]=1;
rom_serial_cod_array[445]=0;
rom_serial_cod_array[446]=1;
rom_serial_cod_array[447]=0;
rom_serial_cod_array[448]=1;
rom_serial_cod_array[449]=1;
rom_serial_cod_array[450]=0;
rom_serial_cod_array[451]=0;
rom_serial_cod_array[452]=0;
rom_serial_cod_array[453]=0;
rom_serial_cod_array[454]=0;
rom_serial_cod_array[455]=0;
rom_serial_cod_array[456]=0;
rom_serial_cod_array[457]=0;
rom_serial_cod_array[458]=0;
rom_serial_cod_array[459]=0;
rom_serial_cod_array[460]=0;
rom_serial_cod_array[461]=0;
rom_serial_cod_array[462]=0;
rom_serial_cod_array[463]=0;
rom_serial_cod_array[464]=0;
rom_serial_cod_array[465]=0;
rom_serial_cod_array[466]=0;
rom_serial_cod_array[467]=0;
rom_serial_cod_array[468]=0;
rom_serial_cod_array[469]=0;
rom_serial_cod_array[470]=0;
rom_serial_cod_array[471]=0;
rom_serial_cod_array[472]=0;
rom_serial_cod_array[473]=0;
rom_serial_cod_array[474]=0;
rom_serial_cod_array[475]=0;
rom_serial_cod_array[476]=0;
rom_serial_cod_array[477]=0;
rom_serial_cod_array[478]=0;
rom_serial_cod_array[479]=0;
rom_serial_cod_array[480]=0;
rom_serial_cod_array[481]=0;
rom_serial_cod_array[482]=0;
rom_serial_cod_array[483]=0;
rom_serial_cod_array[484]=0;
rom_serial_cod_array[485]=0;
rom_serial_cod_array[486]=0;
rom_serial_cod_array[487]=0;
rom_serial_cod_array[488]=0;
rom_serial_cod_array[489]=0;
rom_serial_cod_array[490]=1;
rom_serial_cod_array[491]=1;
# 369 "coder_env.cc" 2

	
# 379 "coder_env.cc"


	index = 0;
	frame = 0;

	match = true;
	
	while(index< 492 ) {
	 
 
		for(i=0; i<((244+1) +1); i++) {
			{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  rec_bit = serial_coded_prm->read();  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}  
			if(rom_serial_cod_array[index] != rec_bit) {
				match = false;
				break;
			}
			index++;




		}

		if(match) {
			frame++;








			diag_printf ("RadioSubSystem: Received Frame %d, check OK.\n", frame);




		} else {
			break;
		}
		 
 
 
	}
	
 









	if(match==true) {
		diag_printf ("Coder test OK.\n");
	} else {
		diag_printf ("Coder test Failed.\n");
	}
	diag_printf ("after %d bits coded.\n",index);


	


	*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.show_results();*(unsigned int *)0x9400000C =0x1; ; ;


	
}



# 103 "coder_tb.cc" 2





 
# 1 "/home/nando/archivos/trabajo/methodology/sw_section.h" 1
 
 
 
 
 
 
 
 
 
 
 
 










 
 
 
 
 

 
 
 
 
 

 

 
 
 


 
 

 




 







 

 




 
 
 
 
 
 
 

# 109 "coder_tb.cc" 2

 
# 1 "coder.cc" 1
 
 
 
 
 
 
 
 
 
 

# 1 "../c_base/coder/coder.h" 1

# 1 "../c_base/coder/../common/codec.h" 1





void Pred_lt_6 (
    Word16 exc[],       
    Word16 T0,          
    Word16 frac,        
    Word16 L_subfr      
);


# 2 "../c_base/coder/coder.h" 2


void code_10i40_35bits (
    Word16 x[],         
    Word16 cn[],        
    Word16 h[],         

    Word16 cod[],       
    Word16 y[],         
    Word16 indx[]       
);

Word16 Enc_lag6 (       
    Word16 T0,          
    Word16 *T0_frac,    
    Word16 *T0_min,     
    Word16 *T0_max,     
    Word16 pit_min,     
    Word16 pit_max,     
    Word16 pit_flag     
);

Word16 q_gain_pitch (    
    Word16 *gain         
);

Word16 q_gain_code (    
    Word16 code[],      
    Word16 lcode,       
    Word16 *gain,       
	Word16 past_qua_en[],  
    Word16 txdtx_ctrl,
    Word16 i_subfr,
	Word16 CN_excitation_gain,
	Word16 gain_code_old_tx[]   
);

Word16 G_pitch (        
    Word16 xn[],        
    Word16 y_1[],        
    Word16 L_subfr      
);

Word16 G_code (         
    Word16 xn[],        
    Word16 y2[]         
);

Word16 Interpol_6 (     
    Word16 *x,          
    Word16 frac         
);
void Int_lpc (
    Word16 lsp_old[],   
    Word16 lsp_mid[],   

    Word16 lsp_new[],   

    Word16 Az[]         
);
void Int_lpc2 (
    Word16 lsp_old[],   
    Word16 lsp_mid[],   

    Word16 lsp_new[],   

    Word16 Az[]         

);

Word16 Pitch_fr6 (      
    Word16 exc[],       
    Word16 xn[],        
    Word16 h[],         

    Word16 L_subfr,     
    Word16 t0_min,      
    Word16 t0_max,      
    Word16 i_subfr,     
    Word16 *pit_frac    
);

Word16 Pitch_ol (       
    Word16 signal[],    
                        
    Word16 pit_min,     
    Word16 pit_max,     
    Word16 L_frame      
);

void Pred_lt_6 (
    Word16 exc[],       
    Word16 T0,          
    Word16 frac,        
    Word16 L_subfr      
);

void Q_plsf_5 (
    Word16 *lsp1,       
    Word16 *lsp2,       
    Word16 *lsp1_q,     
    Word16 *lsp2_q,     
    Word16 *indice,     
    Word16 txdtx_ctrl,  
	Word16 past_r2_q[],  
	Word16 lsf_old_tx[][10 ]  
);
# 12 "coder.cc" 2

# 1 "../c_base/coder/window2.tab" 1
 

static const Word16 window_232_8[240 ] =
{
    2621, 2623, 2627, 2634, 2644, 2656, 2671, 2689, 2710, 2734,
    2760, 2789, 2821, 2855, 2893, 2933, 2975, 3021, 3069, 3120,
    3173, 3229, 3288, 3350, 3414, 3481, 3550, 3622, 3697, 3774,
    3853, 3936, 4021, 4108, 4198, 4290, 4385, 4482, 4582, 4684,
    4788, 4895, 5004, 5116, 5230, 5346, 5464, 5585, 5708, 5833,
    5960, 6090, 6221, 6355, 6491, 6629, 6769, 6910, 7054, 7200,
    7348, 7498, 7649, 7803, 7958, 8115, 8274, 8434, 8597, 8761,
    8926, 9093, 9262, 9432, 9604, 9778, 9952, 10129, 10306, 10485,
    10665, 10847, 11030, 11214, 11399, 11586, 11773, 11962, 12152, 12342,
    12534, 12727, 12920, 13115, 13310, 13506, 13703, 13901, 14099, 14298,
    14497, 14698, 14898, 15100, 15301, 15504, 15706, 15909, 16112, 16316,
    16520, 16724, 16928, 17132, 17337, 17541, 17746, 17950, 18155, 18359,
    18564, 18768, 18972, 19175, 19379, 19582, 19785, 19987, 20189, 20390,
    20591, 20792, 20992, 21191, 21390, 21588, 21785, 21981, 22177, 22372,
    22566, 22759, 22951, 23143, 23333, 23522, 23710, 23897, 24083, 24268,
    24451, 24633, 24814, 24994, 25172, 25349, 25525, 25699, 25871, 26042,
    26212, 26380, 26546, 26711, 26874, 27035, 27195, 27353, 27509, 27664,
    27816, 27967, 28115, 28262, 28407, 28550, 28691, 28830, 28967, 29102,
    29234, 29365, 29493, 29619, 29743, 29865, 29985, 30102, 30217, 30330,
    30440, 30548, 30654, 30757, 30858, 30956, 31052, 31146, 31237, 31326,
    31412, 31495, 31576, 31655, 31730, 31804, 31874, 31942, 32008, 32071,
    32131, 32188, 32243, 32295, 32345, 32392, 32436, 32477, 32516, 32552,
    32585, 32615, 32643, 32668, 32690, 32709, 32726, 32740, 32751, 32759,
    32765, 32767, 32767, 32097, 30112, 26895, 22576, 17333, 11380, 4962
};

 

static const Word16 window_160_80[240 ] =
{
    2621, 2624, 2633, 2648, 2668, 2695, 2727, 2765, 2809, 2859,
    2915, 2976, 3043, 3116, 3194, 3279, 3368, 3464, 3565, 3671,
    3783, 3900, 4023, 4151, 4285, 4423, 4567, 4716, 4870, 5029,
    5193, 5362, 5535, 5714, 5897, 6084, 6277, 6473, 6674, 6880,
    7089, 7303, 7521, 7742, 7968, 8197, 8430, 8667, 8907, 9151,
    9398, 9648, 9902, 10158, 10417, 10680, 10945, 11212, 11482, 11755,
    12030, 12307, 12586, 12867, 13150, 13435, 13722, 14010, 14299, 14590,
    14882, 15175, 15469, 15764, 16060, 16356, 16653, 16950, 17248, 17546,
    17844, 18141, 18439, 18736, 19033, 19330, 19625, 19920, 20214, 20507,
    20799, 21090, 21380, 21668, 21954, 22239, 22522, 22803, 23083, 23360,
    23635, 23907, 24177, 24445, 24710, 24972, 25231, 25488, 25741, 25991,
    26238, 26482, 26722, 26959, 27192, 27422, 27647, 27869, 28087, 28300,
    28510, 28715, 28916, 29113, 29305, 29493, 29676, 29854, 30028, 30197,
    30361, 30519, 30673, 30822, 30966, 31105, 31238, 31366, 31489, 31606,
    31718, 31825, 31926, 32021, 32111, 32195, 32273, 32346, 32413, 32475,
    32530, 32580, 32624, 32662, 32695, 32721, 32742, 32756, 32765, 32767,
    32767, 32756, 32720, 32661, 32578, 32471, 32341, 32188, 32012, 31813,
    31592, 31349, 31084, 30798, 30492, 30165, 29818, 29453, 29068, 28666,
    28247, 27810, 27358, 26891, 26408, 25913, 25404, 24883, 24350, 23807,
    23255, 22693, 22124, 21548, 20965, 20378, 19786, 19191, 18593, 17994,
    17395, 16796, 16199, 15604, 15012, 14424, 13842, 13265, 12696, 12135,
    11582, 11039, 10507, 9986, 9477, 8981, 8499, 8031, 7579, 7143,
    6723, 6321, 5937, 5571, 5225, 4898, 4591, 4305, 4041, 3798,
    3577, 3378, 3202, 3048, 2918, 2812, 2729, 2669, 2633, 2621
};
# 13 "coder.cc" 2

# 1 "../c_base/coder/vad.h" 1
 












 
struct _fp
{
    Word16 e;           
    Word16 m;           
};

typedef struct _fp Pfloat;

void vad_reset (void);

Word16 vad_computation (
    Word16 r_h[],
    Word16 r_l[],
    Word16 scal_acf,
    Word16 rc[],
    Word16 ptch
);

void energy_computation (
    Word16 r_h[],
    Word16 scal_acf,
    Word16 rvad[],
    Word16 scal_rvad,
    Pfloat * acf0,
    Pfloat * pvad
);

void acf_averaging (
    Word16 r_h[],
    Word16 r_l[],
    Word16 scal_acf,
    Word32 L_av0[],
    Word32 L_av1[]
);

void predictor_values (
    Word32 L_av1[],
    Word16 rav1[],
    Word16 *scal_rav1
);

void schur_recursion (
    Word32 L_av1[],
    Word16 vpar[]
);

void step_up (
    Word16 np,
    Word16 vpar[],
    Word16 aav1[]
);

void compute_rav1 (
    Word16 aav1[],
    Word16 rav1[],
    Word16 *scal_rav1
);

Word16 spectral_comparison (
    Word16 rav1[],
    Word16 scal_rav1,
    Word32 L_av0[]
);

void threshold_adaptation (
    Word16 stat,
    Word16 ptch,
    Word16 tone,
    Word16 rav1[],
    Word16 scal_rav1,
    Pfloat pvad,
    Pfloat acf0,
    Word16 rvad[],
    Word16 *scal_rvad,
    Pfloat * thvad
);

void tone_detection (
    Word16 rc[],
    Word16 *tone
);

Word16 vad_decision (
    Pfloat pvad,
    Pfloat thvad
);

Word16 vad_hangover (
    Word16 vvad
);

Word16 periodicity_update (
    Word16 lags[]
);


# 14 "coder.cc" 2

# 1 "../c_base/coder/dtx_cod.h" 1
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

# 1 "../c_base/coder/../common/dtx.h" 1
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 














 






 






 




 



 

 

static const Word16 SID_codeword_bit_idx[95] =
{
     45,  46,  48,  49,  50,  51,  52,  53,  54,  55,
     56,  57,  58,  59,  60,  61,  62,  63,  64,  65,
     66,  67,  68,  94,  95,  96,  98,  99, 100, 101,
    102, 103, 104, 105, 106, 107, 108, 109, 110, 111,
    112, 113, 114, 115, 116, 117, 118, 148, 149, 150,
    151, 152, 153, 154, 155, 156, 157, 158, 159, 160,
    161, 162, 163, 164, 165, 166, 167, 168, 169, 170,
    171, 196, 197, 198, 199, 200, 201, 202, 203, 204,
    205, 206, 207, 208, 209, 212, 213, 214, 215, 216,
    217, 218, 219, 220, 221
};

 
void update_lsf_history (
    Word16 lsf1[10 ],
    Word16 lsf2[10 ],
    Word16 lsf_old[7 ][10 ]
);

void update_lsf_p_CN (
    Word16 lsf_old[7 ][10 ],
    Word16 lsf_p_CN[10 ]
);

 
Word16 update_gcode0_CN (
    Word16 gain_code_old_tx[4 * 7 ]
);

 
void build_CN_code (
    Word16 cod[],
    Word32 *seed
);

 
Word16 pseudonoise (
    Word32 *shift_reg,
    Word16 no_bits
);


# 17 "../c_base/coder/dtx_cod.h" 2


 








void aver_lsf_history (
    Word16 lsf_old[7 ][10 ],
    Word16 lsf1[10 ],
    Word16 lsf2[10 ],
    Word16 lsf_aver[10 ]
);

 
Word16 compute_CN_excitation_gain (
    Word16 res2[40 ]
);

 
Word16 aver_gain_code_history (
    Word16 CN_excitation_gain,
    Word16 gain_code_old[4 * 7 ]
);
# 15 "coder.cc" 2


# 1 "../c_base/common/basic_op.h" 1
 




extern Flag Overflow;
extern Flag Carry;







 





Word16 add (Word16 var1, Word16 var2);     
Word16 sub (Word16 var1, Word16 var2);     
Word16 abs_s (Word16 var1);                
Word16 shl (Word16 var1, Word16 var2);     
Word16 shr (Word16 var1, Word16 var2);     
Word16 mult (Word16 var1, Word16 var2);    
Word32 L_mult (Word16 var1, Word16 var2);  
Word16 negate (Word16 var1);               
Word16 extract_h (Word32 L_var1);          
Word16 extract_l (Word32 L_var1);          
Word16 round (Word32 L_var1);              
Word32 L_mac (Word32 L_var3, Word16 var1, Word16 var2);    
Word32 L_msu (Word32 L_var3, Word16 var1, Word16 var2);    
Word32 L_macNs (Word32 L_var3, Word16 var1, Word16 var2);  

Word32 L_msuNs (Word32 L_var3, Word16 var1, Word16 var2);  

Word32 L_add (Word32 L_var1, Word32 L_var2);     
Word32 L_sub (Word32 L_var1, Word32 L_var2);     
Word32 L_add_c (Word32 L_var1, Word32 L_var2);   
Word32 L_sub_c (Word32 L_var1, Word32 L_var2);   
Word32 L_negate (Word32 L_var1);                 
Word16 mult_r (Word16 var1, Word16 var2);        
Word32 L_shl (Word32 L_var1, Word16 var2);       
Word32 L_shr (Word32 L_var1, Word16 var2);       
Word16 shr_r (Word16 var1, Word16 var2);         

Word16 mac_r (Word32 L_var3, Word16 var1, Word16 var2);  

Word16 msu_r (Word32 L_var3, Word16 var1, Word16 var2);  

Word32 L_deposit_h (Word16 var1);         
Word32 L_deposit_l (Word16 var1);         

Word32 L_shr_r (Word32 L_var1, Word16 var2);  

Word32 L_abs (Word32 L_var1);             
Word32 L_sat (Word32 L_var1);             
Word16 norm_s (Word16 var1);              
Word16 div_s (Word16 var1, Word16 var2);  
Word16 norm_l (Word32 L_var1);               

# 17 "coder.cc" 2

# 1 "../c_base/common/oper_32b.h" 1
 

void L_Extract (Word32 L_32, Word16 *hi, Word16 *lo);
Word32 L_Comp (Word16 hi, Word16 lo);
Word32 Mpy_32 (Word16 hi1, Word16 lo1, Word16 hi2, Word16 lo2);
Word32 Mpy_32_16 (Word16 hi, Word16 lo, Word16 n);
Word32 Div_32 (Word32 L_num, Word16 denom_hi, Word16 denom_lo);
# 18 "coder.cc" 2


# 1 "pre_process.cc" 1
 
 
 
 
 
 
 
 
 
 
 
 

 
 
 
 
 
 
 
 
 
 



 










struct   pre_process   :public uc_module   {
public:
	uc_port <sc_fifo_in_if<Word16> >		sample_in;
 
	uc_port <sc_fifo_out_if<Word16> >	sample_1_out;
	uc_port <sc_fifo_out_if<Word16> >	sample_2_out;
	uc_port <sc_fifo_out_if<Word16> >	sample_3_out;	
	uc_port <sc_fifo_out_if<bool> >		reset_flag_out_1;
	uc_port <sc_fifo_out_if<bool> >		reset_flag_out_2;
	uc_port <sc_fifo_out_if<bool> >		reset_flag_out_3;
	uc_port <sc_fifo_out_if<bool> >		reset_flag_out_4;
	uc_port <sc_fifo_out_if<bool> >		reset_flag_out_5;
 

	sc_fifo_SS <Word16>	*IN_SAMPLE;
	sc_fifo_SS <Word16>	*PREPROC_INBAND_RESET;
	
	void pre_filtering();
	void homing_frame_test();
	
	typedef   pre_process   UC_CURRENT_USER_MODULE;   pre_process  (uc_module_name)   {
		execution_context.register_thread_process( static_cast<UC_ENTRY_FUNC> (&   UC_CURRENT_USER_MODULE  ::     pre_filtering     ) , this, "pre_filtering",8192 )   ;
		execution_context.register_thread_process( static_cast<UC_ENTRY_FUNC> (&   UC_CURRENT_USER_MODULE  ::     homing_frame_test     ) , this, "homing_frame_test",8192 )   ;
		IN_SAMPLE = new sc_fifo_SS <Word16>("IN_SAMPLE",160 );
		PREPROC_INBAND_RESET = new sc_fifo_SS <Word16>("PREPROC_INBAND_RESET",1);
	}		
};	

void pre_process::pre_filtering() {
	
	Word16 reset;

	 
	const Word16 b[3] = {1899, -3798, 1899};
	const Word16 a[3] = {4096, 7807, -3733};
	
	Word16	i;  
	
    Word16 x2;
    Word32 L_tmp;
	
	Word16 L_tmp_round;

	 
	 

	Word16 y2_hi, y2_lo, y1_hi, y1_lo, x0, x1;
	
*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x94000008 =0x0; ;*(unsigned int *)0x9400000C =0x1; ; ;	
	
	while(true) {



		 
		 
		y2_hi = 0;
		y2_lo = 0;
		y1_hi = 0;
		y1_lo = 0;
		x0 = 0;
		x1 = 0;
		
		while(true) {
			
			for(i=0;i< 160 ; i++) {
				x2 = x1;                    
				x1 = x0;                    
				 
				{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  x0 = sample_in->read();  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}  
		
				{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  IN_SAMPLE->write(x0);  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}  
		 
				
				x0 = x0 & 0xfff8;   
				
				 
				 
		
				L_tmp = Mpy_32_16 (y1_hi, y1_lo, a[1]);
				L_tmp = L_add (L_tmp, Mpy_32_16 (y2_hi, y2_lo, a[2]));
				L_tmp = L_mac (L_tmp, x0, b[0]);
				L_tmp = L_mac (L_tmp, x1, b[1]);
				L_tmp = L_mac (L_tmp, x2, b[2]);
				L_tmp = L_shl (L_tmp, 3);
				L_tmp_round = round (L_tmp);  
		 
		 
				{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  sample_1_out->write(L_tmp_round);  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}  
				{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  sample_2_out->write(L_tmp_round);  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}  
				{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  sample_3_out->write(L_tmp_round);  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}  
		 
				y2_hi = y1_hi;              
				y2_lo = y1_lo;              
				L_Extract (L_tmp, &y1_hi, &y1_lo);
			}
			
			 
			 
			 
			{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  reset = PREPROC_INBAND_RESET->read();  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}  
			
			if(reset) break;
		}
	}
}

void pre_process::homing_frame_test() {
    Word16	i;
	Word16	sample;
	bool homing_frame;

*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x94000008 =0x0; ;*(unsigned int *)0x9400000C =0x1; ; ;
	
	while(true) {
		homing_frame = false;
 
		for (i = 0; i < 160 ; i++) {
 
			 
			 
			 
			 
			 
			{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  sample = IN_SAMPLE->read();  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}  
			homing_frame = homing_frame || (sample ^ 0x0008 );			
			 
			 
			 
			 
			 
			 
			 
			 
			 
			 
			 
		}





		{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  PREPROC_INBAND_RESET->write(!homing_frame);  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}    
		{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  reset_flag_out_1->write(!homing_frame);  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}    
		{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  reset_flag_out_2->write(!homing_frame);  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}    
		{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  reset_flag_out_3->write(!homing_frame);  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}    
		{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  reset_flag_out_4->write(!homing_frame);  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}    
		{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  reset_flag_out_5->write(!homing_frame);  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}    
 



    }
}


# 20 "coder.cc" 2

# 1 "frame_lsp.cc" 1
 
 
 
 
 
 
 
 
 
 
 
 

 
 
 
 
 
 
 
 
 

struct   frame_lsp   :public uc_module   {
public:
	 
	uc_port <sc_fifo_in_if<bool> >		dtx_mode_in;
	uc_port <sc_fifo_out_if<bool> >		dtx_mode_out_1;
	uc_port <sc_fifo_out_if<bool> >		dtx_mode_out_2;
	uc_port <sc_fifo_out_if<bool> >		dtx_mode_out_3;
	uc_port <sc_fifo_in_if<bool> >		inband_reset_in;	 
	uc_port <sc_fifo_in_if<Word16> >		txdtx_ctrl_in;
	
	uc_port <sc_fifo_in_if<Word16> >		sample_in;	 
	uc_port <sc_fifo_in_if<Word16> >		A13_in;		 
	
	 
	uc_port <sc_fifo_out_if<Word16> >	A24_out;	 
	
	 
	uc_port <sc_fifo_out_if<Word16> >	lsp_out;   	 
													 
	uc_port <sc_fifo_out_if<Word16> >	Aq_out;
	
	 
	uc_port <sc_fifo_out_if<Word16> >	r_out;  		 
	uc_port <sc_fifo_out_if<Word16> >	scal_acf_out;
	uc_port <sc_fifo_out_if<Word16> >	rc_out;

	uc_port <sc_fifo_out_if<Word16> >	prm_out;  		 
	
	void frame_lsp_func();
	
	typedef   frame_lsp   UC_CURRENT_USER_MODULE;   frame_lsp  (uc_module_name)   {
		execution_context.register_thread_process( static_cast<UC_ENTRY_FUNC> (&   UC_CURRENT_USER_MODULE  ::     frame_lsp_func     ) , this, "frame_lsp_func",8192 )   ;
	}
	
};

void frame_lsp::frame_lsp_func() {

	 
	Word16 i;
	
	bool reset;
	
	bool	dtx_mode_var;
	Word16 txdtx_ctrl_var;
	
	 
	 
	 
	 
	 
	 
	Word16 x[240 ];

    Word16 scal_acf;
	
	Word16 r_l[(10 +1) ], r_h[(10 +1) ];       
	Word16 rc[4];
	
    Word16 lsp_new[10 ];
	Word16 lsp_new_q[10 ];  
	
    Word16 lsp_mid[10 ];
	Word16 lsp_mid_q[10 ];  

	Word16 lsp_old[10 ];
	Word16 lsp_old_q[10 ];

	Word16 A2[(10 +1) ], A4[(10 +1) ]; 		 
	Word16 Aq_t[((10 +1) ) * 4];	 

	 
	Word16 old_A[10  + 1];

	 
	Word16 past_r2_q[10 ];
	 
	Word16 lsf_old_tx[7 ][10 ];

	 
	Word16 enc_parameters[5];

*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x94000008 =0x0; ;*(unsigned int *)0x9400000C =0x1; ; ;

	 
	 
	 



	{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  dtx_mode_var = dtx_mode_in->read();  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}  
	{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  dtx_mode_out_1->write(dtx_mode_var);  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}  
	{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  dtx_mode_out_2->write(dtx_mode_var);  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}  
	{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  dtx_mode_out_3->write(dtx_mode_var);  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}  




	while(true) {



		 
		
		 
	
		lsp_old[0] = 30000;
		lsp_old[1] = 26000;
		lsp_old[2] = 21000;
		lsp_old[3] = 15000;
		lsp_old[4] = 8000;
		lsp_old[5] = 0;
		lsp_old[6] = -8000;
		lsp_old[7] = -15000;
		lsp_old[8] = -21000;
		lsp_old[9] = -26000;
		
		 
		Copy (lsp_old, lsp_old_q, 10 );
	
		 
		Set_zero (x, 240 - 160 );
		
		 
		old_A[0] = 4096;            
		for (i = 1; i < 10  + 1; i++) {
			old_A[i] = 0;
		}
		
		 
		for (i = 0; i < 10 ; i++) {
			past_r2_q[i] = 0;
		}

		 
		for (i = 0; i < 7 ; i++) {
			lsf_old_tx[i][0] = 1384;
			lsf_old_tx[i][1] = 2077;
			lsf_old_tx[i][2] = 3420;
			lsf_old_tx[i][3] = 5108;
			lsf_old_tx[i][4] = 6742;
			lsf_old_tx[i][5] = 8122;
			lsf_old_tx[i][6] = 9863;
			lsf_old_tx[i][7] = 11092;
			lsf_old_tx[i][8] = 12714;
			lsf_old_tx[i][9] = 13701;
		}
				
		while(true) {
			
			 
		
			 
			for (i = 0; i < 10 ; i++) {
				{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  lsp_out->write(lsp_old[i]);  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}  
			}






			for (i = 0; i < 160 ; i++) {
				{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  x[i+ 240 - 160 ]=sample_in->read();  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}  
			}
			






			
			 
			 
			 
			scal_acf = Autocorr (x, 10 , r_h, r_l, window_160_80);
										 
		
			Lag_window (10 , r_h, r_l);    

# 216 "frame_lsp.cc"


			Levinson (r_h, r_l, old_A, A2, rc);  








			 
			for(i=0;i< (10 +1) ;i++) {








				{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  A24_out->write(A2[i]);  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}  
			}
			
			Az_lsp (A2, lsp_mid, lsp_old);  




	 
			for(i=0;i< 10 ;i++) {
				{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  lsp_out->write(lsp_mid[i]);  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}  
			}



			 
			 
			 
			
			 
			scal_acf = Autocorr (x, 10 , r_h, r_l, window_232_8);
			
			 
			 
			Copy (&x[160 ], x, 240  - 160 );
			
			 
			 
			 
			if(dtx_mode_var) {



				{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  scal_acf_out->write(scal_acf);  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}  



			}
			
			Lag_window (10 , r_h, r_l);    

# 289 "frame_lsp.cc"

			
			 
			if(dtx_mode_var) {



				for (i=0;i< (10 +1) ;i++) {
					{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  r_out->write(r_h[i]);  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}  
				}



				for (i=0;i< (10 +1) ;i++) {
					{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  r_out->write(r_l[i]);  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}  
				}



			}
			
			Levinson (r_h, r_l, old_A, A4, rc);  

# 320 "frame_lsp.cc"


			 
			for(i=0;i< (10 +1) ;i++) {
				{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  A24_out->write(A4[i]);  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}  
			}
			
			 
			if(dtx_mode_var) {		
				for (i=0;i<4;i++) {
					{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  rc_out->write(rc[i]);  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}  
				}
			}
				
			Az_lsp (A4, lsp_new, lsp_mid);  



	 
			for(i=0;i< 10 ;i++) {
				{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  lsp_out->write(lsp_new[i]);  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}  
			}



			
			 
			{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  txdtx_ctrl_var = txdtx_ctrl_in->read();  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}  

# 369 "frame_lsp.cc"

			 
			Q_plsf_5 (lsp_mid, lsp_new, lsp_mid_q, lsp_new_q, enc_parameters, txdtx_ctrl_var,past_r2_q,lsf_old_tx);									

# 391 "frame_lsp.cc"

			 
			for(i=0;i<5;i++) {
				{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  prm_out->write(enc_parameters[i]);  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}  
			}

			 
			
			if ((txdtx_ctrl_var & 0x0001 ) != 0)
			{
				Int_lpc (lsp_old_q, lsp_mid_q, lsp_new_q, Aq_t);
				
				for(i=0;i<(4* (10 +1) );i++) {
					{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  Aq_out->write(Aq_t[i]);  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}  
				}
		
				 
				for (i = 0; i < 10 ; i++)
				{
					lsp_old[i] = lsp_new[i];                             
					lsp_old_q[i] = lsp_new_q[i];                         
				}
			}
			else
			{
				 
				for (i = 0; i < (10 +1) ; i++)	
				{
					 
					Aq_t[i + (10 +1) ] = A2[i];
					 
					Aq_t[i + (10 +1)  * 3] = A4[i];                
				}
				for (i = 0; i < (10 +1) ; i++) {
					{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  Aq_t[i] = A13_in->read();  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}  
				}
				for (i = 0; i < (10 +1) ; i++) {
					{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  Aq_t[i + (10 +1)  * 2] = A13_in->read();  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}  
				}
		
				for(i=0;i<(4* (10 +1) );i++) {
					{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  Aq_out->write(Aq_t[i]);  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}  
				}
								
				 
				for (i = 0; i < 10 ; i++)
				{
					lsp_old[i] = lsp_new[i];                             
					lsp_old_q[i] = lsp_new[i];                           
				}
				
			}
			






			 
			 
			 
			 
			{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  reset = inband_reset_in->read();  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}  
			if(reset) break;
				
			 
			 
			 
			 
			 
			 
			 
			 
			 
			
			 
			 
			
		}	 
	}	 
}
# 21 "coder.cc" 2

# 1 "vad_computation.cc" 1
 
 
 
 
 
 
 
 
 
 
 
 

 
 
 



struct   vad_computation_module   :public uc_module   {
public:
	 
	uc_port <sc_fifo_in_if<bool> >			dtx_mode_in;
	uc_port <sc_fifo_in_if<bool> >			inband_reset_in;	 
	
	uc_port <sc_fifo_in_if<Word16> >			r_in;  
	uc_port <sc_fifo_in_if<Word16> >			scal_acf_in;
	uc_port <sc_fifo_in_if<Word16> >			rc_in;
	
	uc_port <sc_fifo_in_if<Word16> >			lags_in;
	
	 
	uc_port <sc_fifo_out_if<Word16> >		txdtx_ctrl_out_1;
	uc_port <sc_fifo_out_if<Word16> >		txdtx_ctrl_out_2;
	uc_port <sc_fifo_out_if<Word16> >		txdtx_ctrl_out_3;
	uc_port <sc_fifo_out_if<Word16> >		txdtx_ctrl_out_4;
	uc_port <sc_fifo_out_if<Word16> >		txdtx_ctrl_out_5;	
	uc_port <sc_fifo_out_if<bool> >			L_pn_seed_tx_reset_out;

	 
	 
	 
	 

	bool tx_dtx (Word16 VAD_flag, Word16 *txdtx_ctrl,Word16 &txdtx_hangover,Word16 &txdtx_N_elapsed);
	
	void vad_comp_fun();
	
	typedef   vad_computation_module   UC_CURRENT_USER_MODULE;   vad_computation_module  (uc_module_name)   {
		execution_context.register_thread_process( static_cast<UC_ENTRY_FUNC> (&   UC_CURRENT_USER_MODULE  ::     vad_comp_fun     ) , this, "vad_comp_fun",8192 )   ;
	}

};


void vad_computation_module::vad_comp_fun() {
	
	bool reset;
 
	int i;
	bool dtx_mode_var;
	Word16 txdtx_ctrl_var;	
	
	Word16 r_l[(10 +1) ], r_h[(10 +1) ];       
	Word16 scal_acf;
	Word16 rc[4];
	
	bool ptch_flag;
	
	Word16 lags[2];

	Word16 VAD_flag;

	 
	bool reset_PN_seed;
	
	 
	Word16 txdtx_hangover;
	 
	Word16 txdtx_N_elapsed; 

*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x94000008 =0x0; ;*(unsigned int *)0x9400000C =0x1; ; ;

	 
	 
	 



	{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  dtx_mode_var = dtx_mode_in->read();  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}  




	while(true) {



		 

		 
		ptch_flag = true;
		
		 
		vad_reset ();
		
		 
		txdtx_ctrl_var = 0x0001  | 0x0002 ;
		
		txdtx_hangover = 7 ;
		txdtx_N_elapsed = 0x7fff;
		
		while(true) {	
			
			 
			
			if (dtx_mode_var) {



				 
				for(i=0;i< (10 +1) ;i++) {
					{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  r_h[i] = r_in->read();  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}  
				}
	
				for(i=0;i< (10 +1) ;i++) {
					{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  r_l[i] = r_in->read();  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}  
				}
				
				{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  scal_acf = scal_acf_in->read();  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}  



				for(i=0;i<4;i++) {
					{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  rc[i] = rc_in->read();  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}  
				}
				
	 
# 155 "vad_computation.cc"


				 
				VAD_flag = vad_computation (r_h, r_l, scal_acf, rc, (Word16) ptch_flag);







				reset_PN_seed = tx_dtx (VAD_flag, &txdtx_ctrl_var,txdtx_hangover,txdtx_N_elapsed);  




				 
				{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  L_pn_seed_tx_reset_out->write(reset_PN_seed);  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}  

				 
				{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  txdtx_ctrl_out_1-> write(txdtx_ctrl_var);  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}  
				{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  txdtx_ctrl_out_2-> write(txdtx_ctrl_var);  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}  
				{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  txdtx_ctrl_out_3-> write(txdtx_ctrl_var);  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}  
				{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  txdtx_ctrl_out_4-> write(txdtx_ctrl_var);  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}  
				{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  txdtx_ctrl_out_5-> write(txdtx_ctrl_var);  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}  				
				
				 
				 
				{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  lags[0] = lags_in->read();  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}  
				{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  lags[1] = lags_in->read();  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}  
				
				 
				ptch_flag = periodicity_update (lags);
				
			}
			else
			{
				 
				VAD_flag = 1;   
				txdtx_ctrl_var = 0x0002  | 0x0001 ;







				 
				{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  txdtx_ctrl_out_1-> write(txdtx_ctrl_var);  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}  
				{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  txdtx_ctrl_out_2-> write(txdtx_ctrl_var);  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}  
				{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  txdtx_ctrl_out_3-> write(txdtx_ctrl_var);  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}  
				{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  txdtx_ctrl_out_4-> write(txdtx_ctrl_var);  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}  
				{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  txdtx_ctrl_out_5-> write(txdtx_ctrl_var);  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}  
				
			}

			 
			 
			 
			 
			{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  reset = inband_reset_in->read();  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}  
			if(reset) break;
								
			 
			 
			 
			 
			 
			 
			 
			 
			 
			
			 
			 
			
		}	 
	}	 
}


 























bool vad_computation_module::tx_dtx (
    Word16 VAD_flag,
    Word16 *txdtx_ctrl,  
	Word16 &txdtx_hangover,
	Word16 &txdtx_N_elapsed
)
{



	bool assign_PN_INITIAL_SEED=false;
	
     


    txdtx_N_elapsed = add (txdtx_N_elapsed, 1);

     

     
    if (sub (VAD_flag, 1) == 0)
    {
        txdtx_hangover = 7 ;           
        *txdtx_ctrl = 0x0001  | 0x0002 ;   
    }
    else
    {
        if (txdtx_hangover == 0)
        {
             

            txdtx_N_elapsed = 0;                 

             
              
            if ((*txdtx_ctrl & 0x0004 ) != 0)
            {
                *txdtx_ctrl = 0x0008 
                    | 0x0010 ;              
                 
				assign_PN_INITIAL_SEED=true;
            }
            else
            {
                *txdtx_ctrl = 0x0010 ;     
            }
        }
        else
        {
             
            txdtx_hangover = sub (txdtx_hangover, 1);

             






             
            if (sub (add (txdtx_N_elapsed, txdtx_hangover),
                     (24 + 7  - 1) ) < 0)
            {
                 
                *txdtx_ctrl = 0x0020 ;    
            }
            else
            { 
                if ((*txdtx_ctrl & 0x0004 ) != 0)
                {
                    *txdtx_ctrl = 0x0008 
                        | 0x0004 
                        | 0x0001 ;      
                }
                else
                {
                    *txdtx_ctrl = 0x0004 
                        | 0x0001 ;             
                }
            }
        }
    }
    return assign_PN_INITIAL_SEED;
}

# 22 "coder.cc" 2

# 1 "frame_int_tol.cc" 1
 
 
 
 
 
 
 
 
 
 

 
 
 
 
 
 


struct   frame_int_tol   :public uc_module   {
public:
	 
	uc_port <sc_fifo_in_if<bool> >		dtx_mode_in;
	uc_port <sc_fifo_in_if<bool> >		inband_reset_in;	 
	uc_port <sc_fifo_in_if<Word16> >		txdtx_ctrl_in;
	
	uc_port <sc_fifo_in_if<Word16> >		sample_in;
	uc_port <sc_fifo_in_if<Word16> >		A24_in;  
	uc_port <sc_fifo_in_if<Word16> >		lsp_in;
	
	 
	uc_port <sc_fifo_out_if<Word16> >	A13_out;	 
	uc_port <sc_fifo_out_if<Word16> >	A_out;		
	uc_port <sc_fifo_out_if<Word16> >	lags_out;	 
	uc_port <sc_fifo_out_if<Word16> >	tol_out;	 

	void frame_int_tol_fun();
	
	typedef   frame_int_tol   UC_CURRENT_USER_MODULE;   frame_int_tol  (uc_module_name)   {
		execution_context.register_thread_process( static_cast<UC_ENTRY_FUNC> (&   UC_CURRENT_USER_MODULE  ::     frame_int_tol_fun     ) , this, "frame_int_tol_fun",8192 )   ;
	}
};


void frame_int_tol::frame_int_tol_fun() {

	bool dtx_mode_var;
	Word16 txdtx_ctrl_var;

	bool reset;
	
	Word16 i;
	
	 
	 
	 
	 
	 
	 
	 
	 
	Word16 x[160 + 10 ];
		
	Word16 lsp_old[10 ];		 
	Word16 lsp_mid[10 ];		 
    Word16 lsp_new[10 ];		 
	
    Word16 A_t[((10 +1) ) * 4];   
    Word16 *A;					 
	
    Word16 Ap1[(10 +1) ];		 
    Word16 Ap2[(10 +1) ];		 
	
	Word16 old_wsp[160  + 143 ];
	Word16 *wsp;
	
	Word16 mem_w[10 ];

	Word16 T_ol;

*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x94000008 =0x0; ;*(unsigned int *)0x9400000C =0x1; ; ;




		{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  dtx_mode_var = dtx_mode_in->read();  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}  




	while(true) {



		 
		
		 
		Set_zero (x,10 );
		
		 
		wsp = old_wsp + 143 ;	
		Set_zero (old_wsp, 143 );	
		Set_zero (mem_w, 10 );

		while(true) {
			
			 



			for(i=0;i< 10 ;i++) {
				{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  lsp_old[i] = lsp_in->read();  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}  
			}
	
			 
			for(i=0;i< (10 +1) ;i++) {
				{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  A_t[(10 +1) +i] = A24_in->read();  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}  
			}
	
			for(i=0;i< (10 +1) ;i++) {
				{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  A_t[3* (10 +1) +i] = A24_in->read();  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}  
			}
			
			for(i=0;i< 10 ;i++) {
				{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  lsp_mid[i] = lsp_in->read();  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}  
			}
	
			for(i=0;i< 10 ;i++) {
				{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  lsp_new[i] = lsp_in->read();  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}  
			}
			



			 
			Int_lpc2 (lsp_old, lsp_mid, lsp_new, A_t);
			
			
			for(i=0;i<(4* (10 +1) );i++) {
				{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  A_out->write(A_t[i]);  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}  
			}
			
			 
			{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  txdtx_ctrl_var = txdtx_ctrl_in->read();  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}  
			
			if ((txdtx_ctrl_var & 0x0001 ) == 0) {
				 
				for (i = 0; i < (10 +1) ; i++) {
					{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  A13_out->write(A_t[i]);  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}  
				}
				for (i = 0; i < (10 +1) ; i++) {
					{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  A13_out->write(A_t[i+2* (10 +1) ]);  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}  
				}
			}
			
			 
			 
			 
			 
			 
	
			for(i= 10 ; i<(10 + 160 ); i++) {
				{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  x[i] = sample_in->read();  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}  
			}
			
			A = A_t;                                                     
			for (i = 0; i < 160 ; i += 40 )
			{
				Weight_Ai (A, F_gamma1, Ap1);
				Weight_Ai (A, F_gamma2, Ap2);
	
				Residu (Ap1, &x[i+ 10 ], &wsp[i], 40 );
		
				Syn_filt (Ap2, &wsp[i], &wsp[i], 40 , mem_w, 1);
		
				A += (10 +1) ;                                                
			}
			 
			 
			Copy (&x[160 ], x, 10 );
	
			 
		
			T_ol = Pitch_ol (wsp, 18 , 143 , 80 );
			
			 
			if (dtx_mode_var) {



				{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  lags_out->write(T_ol);  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}  
			}
			{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  tol_out->write(T_ol);  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}  
			
			 
			T_ol = Pitch_ol (&wsp[80 ], 18 , 143 , 80 );
			
			 
			if(dtx_mode_var) {



				{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  lags_out->write(T_ol);  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}  
			}
			{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  tol_out->write(T_ol);  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}  
			
			 
			Copy (&old_wsp[160 ], &old_wsp[0], 143 );
			
			 
			 
			 
			 
			{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  reset = inband_reset_in->read();  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}  
			if(reset) break;
								
			 
			 
			 
			 
			 
			 
			 
			 
			 
			
			 
			 

		}	 
	}	 
}
# 23 "coder.cc" 2

# 1 "subframe_coder.cc" 1
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

	 
	
	
	static const Word16 qua_gain_code[32 ] =
	{
		159, 206, 268, 349, 419, 482, 554, 637,
		733, 842, 969, 1114, 1281, 1473, 1694, 1948,
		2241, 2577, 2963, 3408, 3919, 4507, 5183, 5960,
		6855, 7883, 9065, 10425, 12510, 16263, 21142, 27485
	};

	 
 
	const Word16 pred_energy[4] = {44,37,22,12};

struct   subframe_coder   :public uc_module   {
public:
	 
	uc_port <sc_fifo_in_if<bool> >		dtx_mode_in;
	uc_port <sc_fifo_in_if<bool> >		inband_reset_in;	 
	uc_port <sc_fifo_in_if<Word16> >		txdtx_ctrl_in;
	uc_port <sc_fifo_in_if<Word16> >		sample_in;
	uc_port <sc_fifo_in_if<Word16> >		A_in;  			 
	uc_port <sc_fifo_in_if<Word16> >		Aq_in; 			 
	uc_port <sc_fifo_in_if<Word16> >		Tol_in;
	uc_port <sc_fifo_out_if<Word16> >	prm_out;  		 
	
	uc_port <sc_fifo_in_if<bool> >		L_pn_seed_tx_reset_in;

	 
	 
	 
	 
	 
	 
	 
	 
	Word16 x[160 + 10 ];
	
	 
	Word16 xn[40 ];          
	Word16 res2[40 ];        
    Word16 y_1[40 ];         
	
	Word16 ai_zero[40  + (10 +1) ];
	Word16 *zero;	
	
	Word16 *h1;
	Word16 hvec[40  * 2];
	
	Word16 old_exc[160  + 143  + (10+1) ];
	Word16 *exc;
		
	Word16 mem_syn[10 ], mem_w0[10 ];
	Word16 mem_err[10  + 40 ], *error;
	
	Word16 i_subfr;		 
	
	Word32 L_pn_seed_tx_var;
	
	Word16 buf_p_tx;
	
	void init();

	 
	void subframe_coder::update_gain_code_history_tx (
		Word16 new_gain_code,
		Word16 gain_code_old_tx[4 * 7 ]
	);
	
	Word16 q_gain_code (     
		Word16 code[],       
		Word16 lcode,        
		Word16 *gain,        
		Word16 past_qua_en[],  
		Word16 txdtx_ctrl,
		Word16 i_subfr,
		Word16 CN_excitation_gain,
		Word16 gain_code_old_tx[]   
	);

	
# 1 "../c_base/coder/adaptive_codebook_search.c" 1
 
 
 
 
 
 
 
 
 
 

void Adaptive_Codebook_Search(
 
 
				Word16 txdtx_ctrl_var,  
				Word16 *A,
				Word16 *Aq,
								Word16 *T_op,		 
								Word16 ana[],		 
								Word16 &TO_out,		 
								Word16 &gain_pit_out,  
								Word16 *CN_excitation_gain  
)

{




	Word16 i;
	Word16 pit_flag;
	Word16 T0_frac;
static	Word16 T0_min;
static	Word16 T0_max;
 
 
	
	Word16 T0;		
	
    Word16 Ap1[(10 +1) ];                 
    Word16 Ap2[(10 +1) ];                 
		
        if ((txdtx_ctrl_var & 0x0001 ) != 0)
        {
             
             
             
            Weight_Ai (A, F_gamma1, Ap1);

            Weight_Ai (A, F_gamma2, Ap2);

             
             
             

            for (i = 0; i <= 10 ; i++)
            {
                ai_zero[i] = Ap1[i];                             
            }

            Syn_filt (Aq, ai_zero, h1, 40 , zero, 0);
            
			Syn_filt (Ap2, h1, h1, 40 , zero, 0);

        }
		
         
         
         

         
		Residu (Aq, &x[i_subfr+ 10 ], res2, 40 );    
		
        if ((txdtx_ctrl_var & 0x0001 ) == 0)
        {
             

            *CN_excitation_gain = compute_CN_excitation_gain (res2);
             
        }
        else
        {
            Copy (res2, &exc[i_subfr], 40 );

            Syn_filt (Aq, &exc[i_subfr], error, 40 , mem_err, 0);

            Residu (Ap1, error, xn, 40 );
            
			Syn_filt (Ap2, xn, xn, 40 , mem_w0, 0);  

             
             
             

             
            pit_flag = i_subfr;                                  

             
			if ( i_subfr == 0)
			{
				 
		
				T0_min = sub (T_op[0], 3);
				
				if (sub (T0_min, 18 ) < 0)
				{
					T0_min = 18 ;                                    
				}
				T0_max = add (T0_min, 6);
				 
				if (sub (T0_max, 143 ) > 0)
				{
					T0_max = 143 ;                                    
					T0_min = sub (T0_max, 6);
				}
								
			}
			
             
            if (sub (i_subfr, 80 ) == 0)
            {
                T0_min = sub (T_op[1], 3);

                if (sub (T0_min, 18 ) < 0)
                {
                    T0_min = 18 ;                            
                }
                T0_max = add (T0_min, 6);
				
                if (sub (T0_max, 143 ) > 0)
                {
                    T0_max = 143 ;                            
                    T0_min = sub (T0_max, 6);
                }
                pit_flag = 0;                                    
            }

            T0 = Pitch_fr6 (&exc[i_subfr], xn, h1, 40 , T0_min, T0_max,
                            pit_flag, &T0_frac);                 

			TO_out = T0;
			
            *ana = Enc_lag6 (T0, &T0_frac, &T0_min, &T0_max, 18 ,
                             143 , pit_flag);
        }
        ana++;
         
         

		
        if ((txdtx_ctrl_var & 0x0001 ) != 0)
        {

             
             
             
             
             
             
             
             

            Pred_lt_6 (&exc[i_subfr], T0, T0_frac, 40 );

            Convolve (&exc[i_subfr], h1, y_1, 40 );

            gain_pit_out = G_pitch (xn, y_1, 40 );       

            *ana = q_gain_pitch (&gain_pit_out);                     

        }
        else
        {
            gain_pit_out = 0;                                        
        }

        ana++;                   
                                 
}
# 117 "subframe_coder.cc" 2

	
# 1 "../c_base/coder/innovative_codebook_search.c" 1
 
 
 
 
 
 
 
 
 
 

void Innovative_Codebook_Search(
								Word16 txdtx_ctrl_var,  
								Word16 *Aq,
								Word16 T0,		 
								Word16 gain_pit,  
								Word16 *CN_excitation_gain,  
								Word16 ana[],     
								Word16 synth[],    
								Word16 past_qua_en[],  
								Word32 *L_pn_seed_tx_par,  
								Word16 gain_code_old_tx[]	 
)

{




	
 
	
	Word16 i;
	Word16 j;
	Word16 k;
    Word16 temp;
    Word32 L_temp;
	Word16 gain_code;
	Word16 pit_sharp;	
	
	Word16 xn2[40 ];            
	
    Word16 code[40 ];           
	
    Word16 y2[40 ];             
	
    if ((txdtx_ctrl_var & 0x0001 ) != 0) {
		
		 
         

        for (i = 0; i < 40 ; i++) {
			L_temp = L_mult (y_1[i], gain_pit);
            L_temp = L_shl (L_temp, 3);
            xn2[i] = sub (xn[i], extract_h (L_temp));        

            L_temp = L_mult (exc[i + i_subfr], gain_pit);
            L_temp = L_shl (L_temp, 3);
            res2[i] = sub (res2[i], extract_h (L_temp));     
		}

         
         
         

         
         

        pit_sharp = shl (gain_pit, 3);

        for (i = T0; i < 40 ; i++) {
			temp = mult (h1[i - T0], pit_sharp);
            h1[i] = add (h1[i], temp);
		}

         
         
         
        code_10i40_35bits (xn2, res2, h1, code, y2, ana);

	} else {
		build_CN_code (code, L_pn_seed_tx_par);
 
    }
	
    ana += 10;                                               

    if ((txdtx_ctrl_var & 0x0001 ) != 0) {

		 
         
         

        for (i = T0; i < 40 ; i++) {
			temp = mult (code[i - T0], pit_sharp);
            code[i] = add (code[i], temp);                   
		}

         
         
         

        gain_code = G_code (xn2, y2);                        

	}
    *ana++ = q_gain_code (code, 40 , &gain_code, past_qua_en, txdtx_ctrl_var, i_subfr,*CN_excitation_gain,gain_code_old_tx);
         
     
     
     
     
     
     
     

    for (i = 0; i < 40 ; i++) {
		 

        L_temp = L_mult (exc[i + i_subfr], gain_pit);
        L_temp = L_mac (L_temp, code[i], gain_code);
        L_temp = L_shl (L_temp, 3);
        exc[i + i_subfr] = round (L_temp);                   
    }

    Syn_filt (Aq, &exc[i_subfr], &synth[i_subfr], 40 , mem_syn, 1);

    if ((txdtx_ctrl_var & 0x0001 ) != 0) {	    j = 0;  
        for (i = 40  - 10 ; i < 40 ; i++) {
 
			mem_err[j] = sub (x[i_subfr + i + 10 ], synth[i_subfr + i]);
			
            temp = extract_h (L_shl (L_mult (y_1[i], gain_pit), 3));
            k = extract_h (L_shl (L_mult (y2[i], gain_code), 5));
            mem_w0[j] = sub (xn[i], add (temp, k));
			j++;
        }
	} else {
		for (j = 0; j < 10 ; j++) {
			mem_err[j] = 0;                                  
            mem_w0[j] = 0;                                   
		}
	}
		
}
# 118 "subframe_coder.cc" 2


	 
	void subframe_coder_fun();
	
	typedef   subframe_coder   UC_CURRENT_USER_MODULE;   subframe_coder  (uc_module_name)   {
		execution_context.register_thread_process( static_cast<UC_ENTRY_FUNC> (&   UC_CURRENT_USER_MODULE  ::     subframe_coder_fun     ) , this, "subframe_coder_fun",8192 )   ;
	}
};

void subframe_coder::init() {



	
    exc = old_exc + 143  + (10+1) ;
    zero = ai_zero + (10 +1) ;
    error = mem_err + 10 ;
    h1 = &hvec[40 ];
		
	Set_zero (old_exc, 143  + (10+1) );
    Set_zero (mem_syn, 10 );
    Set_zero (mem_w0, 10 );
    Set_zero (mem_err, 10 );	
    Set_zero (zero, 40 );
    Set_zero (hvec, 40 );    
}

void subframe_coder::subframe_coder_fun() {

	bool dtx_mode_var;
	Word16 txdtx_ctrl_var;
	
	bool reset;
	bool L_pn_seed_tx_reset_var;
	
	int k;
	
	Word16 gain_pit_par;  
	
	Word16 T_op[2]; 	 
	Word16 T0_par;		 
	
	 
	Word16	A_s[(10 +1) ];
	Word16	Aq_s[(10 +1) ];

	 
	Word16	long_term_prm[2];
	Word16	codebook_prm[11];
	
	Word16 syn[160 ];         

	Word16 CN_excitation_gain_par;	

	Word32	L_pn_seed_tx_var;

	 
	 
	Word16 past_qua_en[4];

	 
	Word16 gain_code_old_tx[4 * 7 ];  

*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x94000008 =0x0; ;*(unsigned int *)0x9400000C =0x1; ; ;




	{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  dtx_mode_var = dtx_mode_in->read();  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}  




	while(true) {



		 

		 
		init();
	
		 
		 
		for (k = 0; k < 4; k++) {
			past_qua_en[k] = -2381;  
		}
		
		 
		Set_zero (x,10 );
	
		 
		L_pn_seed_tx_var = 0x70816958L ;
	
		 
		Set_zero (x,10 );
		
		 
	    for (k = 0; k < 4 * 7 ; k++) {
			gain_code_old_tx[k] = 0;
		}

		buf_p_tx = 0;
	
		while(true) {



			 
			 
			
	 
			 
			for (k=0;k< (10 +1) ;k++) {
				{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  A_s[k]  = A_in->read();  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}  
			}
			for (k=0;k< (10 +1) ;k++) {
				{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  Aq_s[k] = Aq_in->read();  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}  
			}
			
			 
			{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  T_op[0] = Tol_in->read();  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}  
			
			i_subfr =0;
	
			 
			for (k= 10 ;k<(160 + 10 );k++) {
				{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  x[k] = sample_in->read();  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}  
			}
				
			 
			 
			txdtx_ctrl_var = txdtx_ctrl_in->read();
	
			Adaptive_Codebook_Search(txdtx_ctrl_var,A_s,Aq_s,T_op,long_term_prm,T0_par,gain_pit_par,&CN_excitation_gain_par);
	
			for (k=0;k<2;k++) {
				{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  prm_out->write(long_term_prm[k]);  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}  
			}
				
			 
			 
			if (dtx_mode_var) {
				{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  L_pn_seed_tx_reset_var = L_pn_seed_tx_reset_in->read();  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}  
				if(L_pn_seed_tx_reset_var) L_pn_seed_tx_var= 0x70816958L ;
			}
			
			Innovative_Codebook_Search(txdtx_ctrl_var,Aq_s,T0_par,gain_pit_par,&CN_excitation_gain_par,codebook_prm,syn,past_qua_en,&L_pn_seed_tx_var,gain_code_old_tx);

			for (k=0;k<11;k++) {
				{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  prm_out->write(codebook_prm[k]);  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}  
			}
			
	 
			 
			for (k=0;k< (10 +1) ;k++) {
				{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  A_s[k]  = A_in->read();  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}  
			}
			for (k=0;k< (10 +1) ;k++) {
				{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  Aq_s[k] = Aq_in->read();  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}  
			}
	
			i_subfr = 40 ;
	
			Adaptive_Codebook_Search(txdtx_ctrl_var,A_s,Aq_s,T_op, long_term_prm,T0_par,gain_pit_par,&CN_excitation_gain_par);

			for (k=0;k<2;k++) {
				{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  prm_out->write(long_term_prm[k]);  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}  
			}
			
			Innovative_Codebook_Search(txdtx_ctrl_var,Aq_s,T0_par,gain_pit_par,&CN_excitation_gain_par,codebook_prm,syn,past_qua_en,&L_pn_seed_tx_var,gain_code_old_tx);

			for (k=0;k<11;k++) {
				{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  prm_out->write(codebook_prm[k]);  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}  
			}
	
			 
			{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  T_op[1] = Tol_in->read();  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}  
	
	 
			 
			for (k=0;k< (10 +1) ;k++) {
				{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  A_s[k]  = A_in->read();  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}  
			}
			for (k=0;k< (10 +1) ;k++) {
				{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  Aq_s[k] = Aq_in->read();  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}  
			}
			
			i_subfr = 2* 40 ;
	
			Adaptive_Codebook_Search(txdtx_ctrl_var,A_s,Aq_s,T_op, long_term_prm,T0_par,gain_pit_par,&CN_excitation_gain_par);
	
			for (k=0;k<2;k++) {
				{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  prm_out->write(long_term_prm[k]);  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}  
			}
			
			Innovative_Codebook_Search(txdtx_ctrl_var,Aq_s,T0_par,gain_pit_par,&CN_excitation_gain_par,codebook_prm,syn,past_qua_en,&L_pn_seed_tx_var,gain_code_old_tx);

			for (k=0;k<11;k++) {
				{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  prm_out->write(codebook_prm[k]);  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}  
			}
			
	 
			 
			for (k=0;k< (10 +1) ;k++) {
				{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  A_s[k]  = A_in->read();  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}  
			}
			for (k=0;k< (10 +1) ;k++) {
				{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  Aq_s[k] = Aq_in->read();  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}  
			}
	
			i_subfr = 3* 40 ;
	
			Adaptive_Codebook_Search(txdtx_ctrl_var,A_s,Aq_s,T_op, long_term_prm,T0_par,gain_pit_par,&CN_excitation_gain_par);
	
			for (k=0;k<2;k++) {
				{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  prm_out->write(long_term_prm[k]);  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}  
			}
	
			Innovative_Codebook_Search(txdtx_ctrl_var,Aq_s,T0_par,gain_pit_par,&CN_excitation_gain_par,codebook_prm,syn,past_qua_en,&L_pn_seed_tx_var,gain_code_old_tx);
			
			for (k=0;k<11;k++) {
				{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  prm_out->write(codebook_prm[k]);  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}  
			}

			 
			Copy (&old_exc[160 ], &old_exc[0], 143  + (10+1) );
	
			 
			Copy (&x[160 ], x, 10 );		
			
			 
			 
			 
			 
			{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  reset = inband_reset_in->read();  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}  
			if(reset) break;
				
			
			 
			 
			 
			 
			 
			 
			 
			 
			 
			
			 
			 
						
		}	 
	}	 
}


 





















void subframe_coder::update_gain_code_history_tx (
    Word16 new_gain_code,
    Word16 gain_code_old_tx[4 * 7 ]
)
{




     
    gain_code_old_tx[buf_p_tx] = new_gain_code;         

     
    if (sub (buf_p_tx, (4 * 7  - 1)) == 0)
    {
        buf_p_tx = 0;                                   
    }
    else
    {
        buf_p_tx = add (buf_p_tx, 1);
    }

    return;
}


 
 



Word16 subframe_coder::q_gain_code (     
    Word16 code[],       
    Word16 lcode,        
    Word16 *gain,        
	Word16 past_qua_en[],  
    Word16 txdtx_ctrl,
    Word16 i_subfr,
	Word16 CN_excitation_gain,
	Word16 gain_code_old_tx[]   
)
{




    Word16 i, index;
    Word16 gcode0, err, err_min, exp, frac;
    Word32 ener, ener_code;
    Word16 aver_gain;
    static Word16 gcode0_CN;

      
    if ((txdtx_ctrl & 0x0001 ) != 0)
    {

         
         
         
         
         
         
         

         
        ener_code = 0;                           
        for (i = 0; i < lcode; i++)
        {
            ener_code = L_mac (ener_code, code[i], code[i]);
        }
         
        ener_code = L_mult (round (ener_code), 26214);

         
        Log2 (ener_code, &exp, &frac);
        ener_code = L_Comp (sub (exp, 30), frac);

         

        ener = 783741L ;                        
        for (i = 0; i < 4; i++)
        {
            ener = L_mac (ener, past_qua_en[i], pred_energy[i]);
        }

         
         
         
         
         
         
         

        ener = L_shr (L_sub (ener, ener_code), 1);
        L_Extract (ener, &exp, &frac);

        gcode0 = extract_l (Pow2 (exp, frac));   

        gcode0 = shl (gcode0, 4);

         
         
         

        err_min = abs_s (sub (*gain, mult (gcode0, qua_gain_code[0])));
        index = 0;               

        for (i = 1; i < 32 ; i++)
        {
            err = abs_s (sub (*gain, mult (gcode0, qua_gain_code[i])));

             
            if (sub (err, err_min) < 0)
            {
                err_min = err;                   
                index = i;                       
            }
        }

        *gain = mult (gcode0, qua_gain_code[index]);
                                                 

         
         
         
         
         
         
         

        for (i = 3; i > 0; i--)
        {
            past_qua_en[i] = past_qua_en[i - 1]; 
        }
        Log2 (L_deposit_l (qua_gain_code[index]), &exp, &frac);

        past_qua_en[0] = shr (frac, 5);          
        past_qua_en[0] = add (past_qua_en[0], shl (sub (exp, 11), 10));
                                                 
        update_gain_code_history_tx (*gain, gain_code_old_tx);
    }
    else
    {
           
        if ((txdtx_ctrl & 0x0008 ) != 0 && (i_subfr == 0))
        {
            gcode0_CN = update_gcode0_CN (gain_code_old_tx);
            gcode0_CN = shl (gcode0_CN, 4);
        }
        *gain = CN_excitation_gain;              

           
        if ((txdtx_ctrl & 0x0010 ) != 0)
        {
            aver_gain = aver_gain_code_history (CN_excitation_gain,
                                                gain_code_old_tx);

             
             
             

            err_min = abs_s (sub (aver_gain, 
                                  mult (gcode0_CN, qua_gain_code[0])));
            index = 0;                           

            for (i = 1; i < 32 ; i++)
            {
                err = abs_s (sub (aver_gain, 
                                  mult (gcode0_CN, qua_gain_code[i])));

                 
                if (sub (err, err_min) < 0)
                {
                    err_min = err;               
                    index = i;                   
                }
            }
        }
        update_gain_code_history_tx (*gain, gain_code_old_tx);

         
         
         
         

        for (i = 0; i < 4; i++)
        {
            past_qua_en[i] = -2381;              
        }
    }

    return index;
}
# 24 "coder.cc" 2

# 1 "serializer.cc" 1
 
 
 
 
 
 
 
 
 
 
 
 

































static const Word16 bitno[57 ] =
    {
        7, 8, 9, 8, 6,                           
        9, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 5,   
        6, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 5,   
        9, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 5,   
        6, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 5    
    };

struct   serializer   :public uc_module   {	
	 
	uc_port <sc_fifo_in_if<Word16> >  	prm_in;
	
	 
	uc_port <sc_fifo_out_if<bool> >			out;
	
	void serializer_fun();
			
	typedef   serializer   UC_CURRENT_USER_MODULE;   serializer  (uc_module_name)   {
		 
		execution_context.register_thread_process( static_cast<UC_ENTRY_FUNC> (&   UC_CURRENT_USER_MODULE  ::     serializer_fun     ) , this, "serializer_fun",8192 )   ;
	}
};

void serializer::serializer_fun() {
	
	 
	int 	parameter_number;
	bool	out_bit;
	
	Word16			parameter;
	uc_uint <9>		par;
	
	Word16		 	bit_number;

*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x94000008 =0x0; ;*(unsigned int *)0x9400000C =0x1; ; ;
	
	parameter_number = 0;
 
		
	while(true) {



		{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  parameter = prm_in->read();  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}  



		par = parameter;
		for(bit_number = bitno[parameter_number]-1; bit_number>=0;bit_number--) {   
			out_bit = par[bit_number];
			{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  out->write(out_bit);  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}  
		}
		if(parameter_number<(57 -1))
			parameter_number++;
		else {
			parameter_number = 0;



		}
	}
	
}
# 25 "coder.cc" 2

# 1 "sid_codeword_encoder.cc" 1
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 
 
 

struct   sid_codeword_encoder   :public uc_module   {

	 
	uc_port <sc_fifo_in_if<bool> >   	in;
	uc_port <sc_fifo_in_if<Word16> > 	txdtx_ctrl_in;
	
	 
	uc_port <sc_fifo_out_if<bool> >		out;
	
	void sid_encoding_fun();

	typedef   sid_codeword_encoder   UC_CURRENT_USER_MODULE;   sid_codeword_encoder  (uc_module_name)   {
		 
		execution_context.register_thread_process( static_cast<UC_ENTRY_FUNC> (&   UC_CURRENT_USER_MODULE  ::     sid_encoding_fun     ) , this, "sid_encoding_fun",8192 )   ;
	}
	
};

void sid_codeword_encoder::sid_encoding_fun() {
	
	bool aux_bit;
	
	unsigned int serial_bit;
	Word16	txdtx_ctrl_var;

*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x94000008 =0x0; ;*(unsigned int *)0x9400000C =0x1; ; ;
	
	while(true) {
 
		{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  txdtx_ctrl_var = txdtx_ctrl_in->read();  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}  
		
		if( (txdtx_ctrl_var& 0x0001 )==0) {
 
			for(serial_bit=0;serial_bit<244;serial_bit++) {
				{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  aux_bit = in->read();  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}  
				 
				if((serial_bit>44)&&(serial_bit<47)) aux_bit=true;
				if((serial_bit>47)&&(serial_bit<69)) aux_bit=true;
				if((serial_bit>93)&&(serial_bit<97)) aux_bit=true;
				if((serial_bit>97)&&(serial_bit<119)) aux_bit=true;
				if((serial_bit>147)&&(serial_bit<172)) aux_bit=true;
				if((serial_bit>195)&&(serial_bit<210)) aux_bit=true;
				if((serial_bit>211)&&(serial_bit<222)) aux_bit=true;
				 
				{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  out->write(aux_bit);  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}  
			}
		} else {
 
			 
			for(serial_bit=0;serial_bit<244;serial_bit++) {
					{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  aux_bit = in->read();  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}  
					{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  out->write(aux_bit);  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}  
			}
		}
		
		 
        if ((txdtx_ctrl_var & 0x0002 ) != 0){



			{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  out->write(true);  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}  
		}
		else {



			{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  out->write(false);  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}  
		}
		
		 
        if ((txdtx_ctrl_var & 0x0001 ) != 0) {



			{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  out->write(true);  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}  
		}
		else {



			{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  out->write(false);  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}  
		}		
	}
}
# 26 "coder.cc" 2

# 1 "cn_encoder.cc" 1
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
struct   CN_encoder   :public uc_module   {
	 
	uc_port <sc_fifo_in_if<Word16> >   	lpc_prm_in;
	uc_port <sc_fifo_in_if<bool> >	  	inband_reset_in;   
	uc_port <sc_fifo_in_if<Word16> >  	txdtx_ctrl_in;   
	
	uc_port <sc_fifo_in_if<Word16> >   	subframe_prm_in;
	
	 
	uc_port <sc_fifo_out_if<Word16> >	prm_out;
	
	void CN_encoder_fun();
			
	typedef   CN_encoder   UC_CURRENT_USER_MODULE;   CN_encoder  (uc_module_name)   {
		execution_context.register_thread_process( static_cast<UC_ENTRY_FUNC> (&   UC_CURRENT_USER_MODULE  ::     CN_encoder_fun     ) , this, "CN_encoder_fun",8192 )   ;
	}
};


void CN_encoder::CN_encoder_fun() {
	
	bool reset;
	
	Word16 old_CN_mem_tx[6];  
	
	Word16 this_frame_txdtx_ctrl;
    Word16 param_number;
	Word16 param;
	Word16 params[39];

*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x94000008 =0x0; ;*(unsigned int *)0x9400000C =0x1; ; ;	
	
	while(true) {



		 
	
		 
		for(param_number=0;param_number<6; param_number++) old_CN_mem_tx[param_number]=0;
		
		while(true) {
			
			{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  this_frame_txdtx_ctrl = txdtx_ctrl_in->read();  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}  

			if ((this_frame_txdtx_ctrl & 0x0001 ) == 0) {
				if( ((this_frame_txdtx_ctrl & 0x0010 ) != 0) && ((this_frame_txdtx_ctrl & 0x0020 ) != 0) ) {
							 
							 
							 
							 
					for (param_number=0;param_number<17;param_number++) {
						if(param_number<5) {
							{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  param = lpc_prm_in->read();  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}  
							old_CN_mem_tx[param_number] = param;
						} else {
							{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  subframe_prm_in->read();  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}  
							param = 0;
						}
						 
						 
						 
						 
						 
						{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  prm_out->write(param);  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}  
					}
					 
					for (param_number=17;param_number<57;param_number++) {
						{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  params[param_number-17] = subframe_prm_in->read();  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}  
					}
					old_CN_mem_tx[5] = params[39];  
					for (param_number=17;param_number<57;param_number++) {
						if(param_number == 17) {
							param = old_CN_mem_tx[5];
						}
						else if(param_number == 30) {
							param = old_CN_mem_tx[5];
						}
						else if(param_number == 43) {
							param = old_CN_mem_tx[5];
						}
						else if(param_number == 56) {
							param = old_CN_mem_tx[5];
						}
						else {
							param = 0;
						}
						{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  prm_out->write(params[param_number-17]);  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}  
					}
						
				} else if ((this_frame_txdtx_ctrl & 0x0010 ) != 0) {				
					 
					for (param_number=0;param_number<57;param_number++) {
						if(param_number<5) {
							{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  param = lpc_prm_in->read();  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}  
						} else {
							if((param_number==17)||(param_number==30)||(param_number==43)||(param_number==56)) {
								{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  param=subframe_prm_in->read();  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}  
							} else {
								{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  subframe_prm_in->read();  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}  
								param = 0;
							}
						}
						{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  prm_out->write(param);  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}  
						if(param_number<5) old_CN_mem_tx[param_number] = param;
						if(param_number==56) old_CN_mem_tx[5] = param;	
					}
				} else if ((this_frame_txdtx_ctrl & 0x0020 ) != 0) {
					 
					for (param_number=0;param_number<57;param_number++) {					
						if(param_number < 5) {
							{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  lpc_prm_in->read();  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}  
							param = old_CN_mem_tx[param_number];
						} else {
							{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  subframe_prm_in->read();  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}  
							if(param_number == 17) {
								param = old_CN_mem_tx[5];
							} else if(param_number == 30) {
								param = old_CN_mem_tx[5];
							} else if(param_number	== 43) {
								param = old_CN_mem_tx[5];
							} else if(param_number == 56) {
								param = old_CN_mem_tx[5];
							} else {
								param = 0;
							}
						}
						{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  prm_out->write(param);  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}  
					}									
				}
			} else {
				 
				for(param_number=0;param_number<57;param_number++) {
					if(param_number<5) {
						{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  param = lpc_prm_in->read();  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}  
						{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  prm_out->write(param);  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}  
					}
					else {
						{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  param = subframe_prm_in->read();  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}  
						{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  prm_out->write(param);  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}  
					}
				}

 









			}
			 
			 
			 
			 
			{*(unsigned int *)0x9400000C =0x0; ;*(unsigned int *)0x94000000 = 0 ;*(unsigned int *)0x9400000C =0x1; ; ;  reset = inband_reset_in->read();  ;*(unsigned int *)0x9400000C =0x0; ;target_prof_hardware.threadCounter();*(unsigned int *)0x9400000C =0x1; ; ;}  
			if(reset) break;
				
			 
			 
			 
			 
			 
			 
			 
			 
			 
			
			 
			 
						
		}	 
	}	 
}
# 27 "coder.cc" 2


struct   EFR_coder   :public uc_module   {
	uc_port <sc_fifo_in_if<bool> >		dtx_mode_in;	 
	uc_port <sc_fifo_in_if<Word16> >		sample_in;		 
	uc_port <sc_fifo_out_if<bool> >		prm_out;		 

	 
	sc_fifo_SS <bool>		*DTX_MODE_1;
	sc_fifo_SS <bool>		*DTX_MODE_2;
	sc_fifo_SS <bool>		*DTX_MODE_3;

	sc_fifo_SS <Word16>		*PREPROC_SAMPLE_1;
	sc_fifo_SS <Word16>		*PREPROC_SAMPLE_2;
	sc_fifo_SS <Word16>		*PREPROC_SAMPLE_3;
	
	sc_fifo_SS <bool>		*INBAND_RESET_1;
	sc_fifo_SS <bool>		*INBAND_RESET_2;
	sc_fifo_SS <bool>		*INBAND_RESET_3;
	sc_fifo_SS <bool>		*INBAND_RESET_4;
	sc_fifo_SS <bool>		*INBAND_RESET_5;
	
	sc_fifo_SS <Word16>		*TXDTX_CTRL_VAD_OUT_1;
	sc_fifo_SS <Word16>		*TXDTX_CTRL_VAD_OUT_2;
	sc_fifo_SS <Word16>		*TXDTX_CTRL_VAD_OUT_3;
	sc_fifo_SS <Word16>		*TXDTX_CTRL_VAD_OUT_4;
	sc_fifo_SS <Word16>		*TXDTX_CTRL_VAD_OUT_5;
	
	sc_fifo_SS <Word16>		*R;
	sc_fifo_SS <Word16>		*SCAL_ACF;
	sc_fifo_SS <Word16>		*RC;
	
	sc_fifo_SS <Word16>		*A13;
	sc_fifo_SS <Word16>		*A24;
	sc_fifo_SS <Word16>		*A_LPC;
	sc_fifo_SS <Word16>		*AQ_LPC;	
	sc_fifo_SS <Word16>		*LSP;  
	sc_fifo_SS <Word16>		*LAGS;	
	sc_fifo_SS <Word16>		*TOLS;

	sc_fifo_SS <bool>		*L_PN_SEED_TX_RESET;		
	
	sc_fifo_SS <Word16>		*LPC_PRM;
	sc_fifo_SS <Word16>		*SUBFRM_PRM;

	sc_fifo_SS <Word16>		*PRM_CN;
	sc_fifo_SS <bool>		*BIT_STREAM;
	
	 
	 
	pre_process					*preproc;
	frame_lsp					*lsp_gen;
	frame_int_tol				*az_tol_gen;
	subframe_coder				*subfr;
	serializer					*Prm2bits;
	vad_computation_module		*vad;
	CN_encoder					*CN_enc;
	sid_codeword_encoder		*sid_cod;
	
	
	typedef   EFR_coder   UC_CURRENT_USER_MODULE;   EFR_coder  (uc_module_name)   {
		
		 
		DTX_MODE_1	= new sc_fifo_SS <bool>(1);
		DTX_MODE_2	= new sc_fifo_SS <bool>(1);
		DTX_MODE_3	= new sc_fifo_SS <bool>(1);
	
		PREPROC_SAMPLE_1	= new sc_fifo_SS <Word16>(160 );
		PREPROC_SAMPLE_2	= new sc_fifo_SS <Word16>(160 );
		PREPROC_SAMPLE_3	= new sc_fifo_SS <Word16>(160 );
		
		INBAND_RESET_1		= new sc_fifo_SS <bool>(1);
		INBAND_RESET_2		= new sc_fifo_SS <bool>(1);
		INBAND_RESET_3		= new sc_fifo_SS <bool>(1);
		INBAND_RESET_4		= new sc_fifo_SS <bool>(1);
		INBAND_RESET_5		= new sc_fifo_SS <bool>(1);
		
		TXDTX_CTRL_VAD_OUT_1	= new sc_fifo_SS <Word16>(1);
		TXDTX_CTRL_VAD_OUT_2	= new sc_fifo_SS <Word16>(1);
		TXDTX_CTRL_VAD_OUT_3	= new sc_fifo_SS <Word16>(1);
		TXDTX_CTRL_VAD_OUT_4	= new sc_fifo_SS <Word16>(1);
		TXDTX_CTRL_VAD_OUT_5	= new sc_fifo_SS <Word16>(1);
		
		R			= new sc_fifo_SS <Word16>((10 +1) );
		SCAL_ACF	= new sc_fifo_SS <Word16>(1);
		RC			= new sc_fifo_SS <Word16>(4);
		
		A13			= new sc_fifo_SS <Word16>((10 +1) );
		A24			= new sc_fifo_SS <Word16>((10 +1) );
		A_LPC		= new sc_fifo_SS <Word16>(4* (10 +1) );
		AQ_LPC		= new sc_fifo_SS <Word16>(4* (10 +1) );
		LSP			= new sc_fifo_SS <Word16>(100);  
		LAGS		= new sc_fifo_SS <Word16>(2);
		TOLS		= new sc_fifo_SS <Word16>(2);
	
		L_PN_SEED_TX_RESET	= new sc_fifo_SS <bool>(1);		
		
		LPC_PRM		= new sc_fifo_SS <Word16>(5);
		SUBFRM_PRM	= new sc_fifo_SS <Word16>(13*4);
		 
	
		PRM_CN		= new sc_fifo_SS <Word16>("PRM_CN",57 );
		BIT_STREAM	= new sc_fifo_SS <bool>("BIT_STREAM",(244+1) -1);
		
		 
		 
		preproc			= new pre_process	("preproc");
		lsp_gen			= new frame_lsp("lsp_gen");
		az_tol_gen		= new frame_int_tol("Az_tol_gen");
		subfr			= new subframe_coder("subfr");
		Prm2bits		= new serializer("Prm2bits");
		vad				= new vad_computation_module("vad");
		CN_enc			= new CN_encoder("CN_enc");
		sid_cod			= new sid_codeword_encoder("sid_cod");
		
		 
		 
		preproc->sample_in(sample_in);
		preproc->sample_1_out(*PREPROC_SAMPLE_1);
		preproc->sample_2_out(*PREPROC_SAMPLE_2);
		preproc->sample_3_out(*PREPROC_SAMPLE_3);
		preproc->reset_flag_out_1(*INBAND_RESET_1);
		preproc->reset_flag_out_2(*INBAND_RESET_2);
		preproc->reset_flag_out_3(*INBAND_RESET_3);
		preproc->reset_flag_out_4(*INBAND_RESET_4);
		preproc->reset_flag_out_5(*INBAND_RESET_5);
		
		 
		lsp_gen->dtx_mode_in(dtx_mode_in);
		lsp_gen->dtx_mode_out_1(*DTX_MODE_1);
		lsp_gen->dtx_mode_out_2(*DTX_MODE_2);
		lsp_gen->dtx_mode_out_3(*DTX_MODE_3);
		lsp_gen->inband_reset_in(*INBAND_RESET_1);
		lsp_gen->txdtx_ctrl_in(*TXDTX_CTRL_VAD_OUT_1);
		lsp_gen->sample_in(*PREPROC_SAMPLE_1);
		lsp_gen->r_out(*R);
		lsp_gen->scal_acf_out(*SCAL_ACF);
		lsp_gen->rc_out(*RC);
		lsp_gen->A24_out(*A24);
		lsp_gen->A13_in(*A13);
		lsp_gen->lsp_out(*LSP);
		lsp_gen->Aq_out(*AQ_LPC);
		lsp_gen->prm_out(*LPC_PRM);
	
		 
		az_tol_gen->dtx_mode_in(*DTX_MODE_1);
		az_tol_gen->inband_reset_in(*INBAND_RESET_2);
		az_tol_gen->txdtx_ctrl_in(*TXDTX_CTRL_VAD_OUT_2);
		az_tol_gen->sample_in(*PREPROC_SAMPLE_2);
		az_tol_gen->A24_in(*A24);
		az_tol_gen->A13_out(*A13);
		az_tol_gen->lsp_in(*LSP);
		az_tol_gen->A_out(*A_LPC);
		az_tol_gen->lags_out(*LAGS);
		az_tol_gen->tol_out(*TOLS);
	
		 
		subfr->dtx_mode_in(*DTX_MODE_2);
		subfr->inband_reset_in(*INBAND_RESET_3);	
		subfr->txdtx_ctrl_in(*TXDTX_CTRL_VAD_OUT_3);
		subfr->sample_in(*PREPROC_SAMPLE_3);
		subfr->L_pn_seed_tx_reset_in(*L_PN_SEED_TX_RESET);
		subfr->A_in(*A_LPC);
		subfr->Aq_in(*AQ_LPC);
		subfr->Tol_in(*TOLS);
		subfr->prm_out(*SUBFRM_PRM);
			
		 
		Prm2bits->prm_in(*PRM_CN);
		Prm2bits->out(*BIT_STREAM);
	
		 
		vad->dtx_mode_in(*DTX_MODE_3);
		vad->inband_reset_in(*INBAND_RESET_4);
		vad->r_in(*R);
		vad->scal_acf_in(*SCAL_ACF);
		vad->rc_in(*RC);
		vad->lags_in(*LAGS);
		vad->txdtx_ctrl_out_1(*TXDTX_CTRL_VAD_OUT_1);
		vad->txdtx_ctrl_out_2(*TXDTX_CTRL_VAD_OUT_2);
		vad->txdtx_ctrl_out_3(*TXDTX_CTRL_VAD_OUT_3);
		vad->txdtx_ctrl_out_4(*TXDTX_CTRL_VAD_OUT_4);
		vad->txdtx_ctrl_out_5(*TXDTX_CTRL_VAD_OUT_5);	
		vad->L_pn_seed_tx_reset_out(*L_PN_SEED_TX_RESET);
		
		 
		CN_enc->lpc_prm_in(*LPC_PRM);
		CN_enc->inband_reset_in(*INBAND_RESET_5);
		CN_enc->txdtx_ctrl_in(*TXDTX_CTRL_VAD_OUT_4);
		CN_enc->subframe_prm_in(*SUBFRM_PRM);
		CN_enc->prm_out(*PRM_CN);
		
		sid_cod->in(*BIT_STREAM);
		sid_cod->txdtx_ctrl_in(*TXDTX_CTRL_VAD_OUT_5);
		sid_cod->out(prm_out);		
		
	}
};
# 111 "coder_tb.cc" 2




int sc_main (int argc, char *argv[]) {

# 129 "coder_tb.cc"






	
# 1 "/home/nando/archivos/trabajo/methodology/sw_section.h" 1
 
 
 
 
 
 
 
 
 
 
 
 










 
 
 
 
 

 
 
 
 
 

 

 
 
 


 
 

 




 







 

 




 
 
 
 
 
 
 

# 135 "coder_tb.cc" 2


	
	 
	
	sc_fifo_SS <bool>		DTX_MODE(1);
	sc_fifo_SS <Word16>		SAMPLE(160 );
	sc_fifo_SS <bool>		SERIAL_LINE(244+2);

	 

	 
	coder_env					env("coder_env");
	 
	env.dtx_mode_out(DTX_MODE);
	env.sample_out(SAMPLE);
	env.serial_coded_prm(SERIAL_LINE);	



	 
	EFR_coder					coder("coder");
	 
	coder.dtx_mode_in(DTX_MODE);
	coder.sample_in(SAMPLE);
	coder.prm_out(SERIAL_LINE);	


# 187 "coder_tb.cc"




    diag_printf ("\n/**************************************************************");
	diag_printf ("\n SYSTEMC ADAPTATION OF EFR CODER");	
	





	diag_printf ("\n SELF TESTABLE SW COMPLETE VERSION");	


	diag_printf ("\n Author: F.Herrera");	
	diag_printf ("\n Microelectronics Engineering Group. TEISA DPT.");	
	diag_printf ("\n University of Cantabria.");	
	diag_printf ("\n BASED ON:");	
    diag_printf ("\n     European digital cellular telecommunications system");
    diag_printf ("\n                12200 bits/s speech codec for");
    diag_printf ("\n          enhanced full rate speech traffic channels\n");
    diag_printf ("\n     Bit-Exact C Simulation Code - Encoder");
    diag_printf ("\n     Version 5.1.0");
    diag_printf ("\n     June 26, 1996");
    diag_printf ("\n**************************************************************/\n\n");








	 

	diag_printf ("Start of execution...\n");

 
 
 
 
 

	
	uc_start (-1);




	 
	diag_printf ("THIS POINT SHOULD NOT BE REACHED!!! (main function sould not not terminate...\n");


	return 0;

}


